use alloc::collections::btree_set::BTreeSet;
use alloc::vec::Vec;
use core::iter;

use crate::core::indices::{
    DataIdx, ElemIdx, FuncIdx, GlobalIdx, LabelIdx, LocalIdx, MemIdx, TableIdx, TypeIdx,
};
use crate::core::reader::section_header::{SectionHeader, SectionTy};
use crate::core::reader::span::Span;
use crate::core::reader::types::element::ElemType;
use crate::core::reader::types::global::Global;
use crate::core::reader::types::memarg::MemArg;
use crate::core::reader::types::{BlockType, FuncType, MemType, NumType, TableType, ValType};
use crate::core::reader::{WasmReadable, WasmReader};
use crate::core::sidetable::{Sidetable, SidetableEntry};
use crate::validation_stack::{LabelInfo, ValidationStack};
use crate::{RefType, ValidationError};

#[allow(clippy::too_many_arguments)]
pub fn validate_code_section(
    wasm: &mut WasmReader,
    section_header: SectionHeader,
    fn_types: &[FuncType],
    type_idx_of_fn: &[usize],
    num_imported_funcs: usize,
    globals: &[Global],
    memories: &[MemType],
    data_count: &Option<u32>,
    tables: &[TableType],
    elements: &[ElemType],
    validation_context_refs: &BTreeSet<FuncIdx>,
    sidetable: &mut Sidetable,
) -> Result<Vec<(Span, usize)>, ValidationError> {
    assert_eq!(section_header.ty, SectionTy::Code);
    let code_block_spans_stps = wasm.read_vec_enumerated(|wasm, idx| {
        // We need to offset the index by the number of functions that were
        // imported. Imported functions always live at the start of the index
        // space.
        let ty_idx = type_idx_of_fn[idx + num_imported_funcs];
        let func_ty = fn_types[ty_idx].clone();

        let func_size = wasm.read_var_u32()?;
        let func_block = wasm.make_span(func_size as usize)?;
        let previous_pc = wasm.pc;

        let locals = {
            let params = func_ty.params.valtypes.iter().cloned();
            let declared_locals = read_declared_locals(wasm)?;
            params.chain(declared_locals).collect::<Vec<ValType>>()
        };

        let mut stack = ValidationStack::new_for_func(func_ty);
        let stp = sidetable.len();

        read_instructions(
            wasm,
            &mut stack,
            sidetable,
            &locals,
            globals,
            fn_types,
            type_idx_of_fn,
            memories,
            data_count,
            tables,
            elements,
            validation_context_refs,
        )?;

        // Check if there were unread trailing instructions after the last END
        if previous_pc + func_size as usize != wasm.pc {
            return Err(ValidationError::ExprHasTrailingInstructions);
        }

        Ok((func_block, stp))
    })?;

    trace!(
        "Read code section. Found {} code blocks",
        code_block_spans_stps.len()
    );

    Ok(code_block_spans_stps)
}

pub fn read_declared_locals(wasm: &mut WasmReader) -> Result<Vec<ValType>, ValidationError> {
    let locals = wasm.read_vec(|wasm| {
        let n = wasm.read_var_u32()? as usize;
        let valtype = ValType::read(wasm)?;

        Ok((n, valtype))
    })?;

    // these checks are related to the official test suite binary.wast file, the first 2 assert_malformed's starting at line 350
    // we check to not have more than 2^32-1 locals, and if that number is okay, we then get to instantiate them all
    // this is because the flat_map and collect take an insane amount of time
    // in total, these 2 tests take more than 240s
    let mut total_no_of_locals: usize = 0;
    for local in &locals {
        let temp = local.0;
        if temp > i32::MAX as usize {
            return Err(ValidationError::TooManyLocals(total_no_of_locals));
        };
        total_no_of_locals = match total_no_of_locals.checked_add(temp) {
            None => return Err(ValidationError::TooManyLocals(total_no_of_locals)),
            Some(n) => n,
        }
    }

    if total_no_of_locals > i32::MAX as usize {
        return Err(ValidationError::TooManyLocals(total_no_of_locals));
    }

    // Flatten local types for easier representation where n > 1
    let locals = locals
        .into_iter()
        .flat_map(|entry| iter::repeat(entry.1).take(entry.0))
        .collect::<Vec<ValType>>();

    Ok(locals)
}

/// Validates a specific branch to some label by its index `label_idx`.
/// Branches are generated by branching instructions and some can even generate multiple branches.
fn validate_branch_and_generate_sidetable_entry(
    wasm: &WasmReader,
    label_idx: usize,
    stack: &mut ValidationStack,
    sidetable: &mut Sidetable,
    unify_to_expected_types: bool,
) -> Result<(), ValidationError> {
    stack.assert_val_types_of_label_jump_types_on_top(label_idx, unify_to_expected_types)?;

    // Get stack length before we mutably borrow the label's `CtrlStackEntry`.
    let stack_len = stack.len();

    let index_of_label_in_ctrl_stack = stack
        .ctrl_stack
        .len()
        .checked_sub(label_idx)
        .and_then(|i| i.checked_sub(1));

    let targeted_ctrl_block_entry = index_of_label_in_ctrl_stack
        .and_then(|idx| stack.ctrl_stack.get_mut(idx))
        .ok_or(ValidationError::InvalidLabelIdx(label_idx))?;

    let valcnt = targeted_ctrl_block_entry.label_types().len();
    let popcnt = stack_len - targeted_ctrl_block_entry.height - valcnt;

    // Now we generate the actual sidetable entry.
    //
    // This entry needs to be backpatched later, except for when it targets a label generated
    // by a `loop` instruction. This is because loops are the only instruction able to perform
    // backwards jumps, so we already know the exact instruction and sidetable pointers for that label.
    // For all other types of labels (blocks, ifs, functions) we generate a partial sidetable entry.
    //
    // This partial sidetable entry abuses the `delta_pc` and `delta_stp` fields to temporarily store
    // the current program counter and side table pointer until we reach the `end` of this label's scope,
    // allowing us to perform the actual backpatching.
    let stp_here = sidetable.len();
    sidetable.push(SidetableEntry {
        delta_pc: wasm.pc as isize,
        delta_stp: stp_here as isize,
        popcnt,
        valcnt,
    });

    match &mut targeted_ctrl_block_entry.label_info {
        LabelInfo::Block { stps_to_backpatch } => stps_to_backpatch.push(stp_here),
        LabelInfo::Loop { ip, stp } => {
            //we already know where to jump to for loops
            sidetable[stp_here].delta_pc = *ip as isize - wasm.pc as isize;
            sidetable[stp_here].delta_stp = *stp as isize - stp_here as isize;
        }
        LabelInfo::If {
            stps_to_backpatch, ..
        } => stps_to_backpatch.push(stp_here),
        LabelInfo::Func { stps_to_backpatch } => stps_to_backpatch.push(stp_here),
        LabelInfo::Untyped => {
            unreachable!("this label is for untyped wasm sequences")
        }
    }
    Ok(())
}

#[allow(clippy::too_many_arguments)]
fn read_instructions(
    wasm: &mut WasmReader,
    stack: &mut ValidationStack,
    sidetable: &mut Sidetable,
    locals: &[ValType],
    globals: &[Global],
    fn_types: &[FuncType],
    type_idx_of_fn: &[usize],
    memories: &[MemType],
    data_count: &Option<u32>,
    tables: &[TableType],
    elements: &[ElemType],
    validation_context_refs: &BTreeSet<FuncIdx>,
) -> Result<(), ValidationError> {
    loop {
        let Ok(first_instr_byte) = wasm.read_u8() else {
            // TODO only do this if EOF
            return Err(ValidationError::ExprMissingEnd);
        };

        #[cfg(debug_assertions)]
        crate::core::utils::print_beautiful_instruction_name_1_byte(first_instr_byte, wasm.pc);

        #[cfg(not(debug_assertions))]
        trace!("Read instruction byte {first_instr_byte:#04X?} ({first_instr_byte}) at wasm_binary[{}]", wasm.pc);

        use crate::core::reader::types::opcode::*;
        match first_instr_byte {
            // nop: [] -> []
            NOP => {}
            // block: [] -> [t*2]
            BLOCK => {
                let block_ty = BlockType::read(wasm)?.as_func_type(fn_types)?;
                let label_info = LabelInfo::Block {
                    stps_to_backpatch: Vec::new(),
                };
                // The types are explicitly popped and pushed in
                // https://webassembly.github.io/spec/core/appendix/algorithm.html
                // therefore types on the stack might change.
                stack.assert_push_ctrl(label_info, block_ty, true)?;
            }
            LOOP => {
                let block_ty = BlockType::read(wasm)?.as_func_type(fn_types)?;
                let label_info = LabelInfo::Loop {
                    ip: wasm.pc,
                    stp: sidetable.len(),
                };
                // The types are explicitly popped and pushed in
                // https://webassembly.github.io/spec/core/appendix/algorithm.html
                // therefore types on the stack might change.
                stack.assert_push_ctrl(label_info, block_ty, true)?;
            }
            IF => {
                let block_ty = BlockType::read(wasm)?.as_func_type(fn_types)?;

                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;

                let stp_here = sidetable.len();
                sidetable.push(SidetableEntry {
                    delta_pc: wasm.pc as isize,
                    delta_stp: stp_here as isize,
                    popcnt: 0,
                    valcnt: block_ty.params.valtypes.len(),
                });

                let label_info = LabelInfo::If {
                    stp: stp_here,
                    stps_to_backpatch: Vec::new(),
                };
                // The types are explicitly popped and pushed in
                // https://webassembly.github.io/spec/core/appendix/algorithm.html
                // therefore types on the stack might change.
                stack.assert_push_ctrl(label_info, block_ty, true)?;
            }
            ELSE => {
                let (mut label_info, block_ty) = stack.assert_pop_ctrl(true)?;
                if let LabelInfo::If {
                    stp,
                    stps_to_backpatch,
                } = &mut label_info
                {
                    if *stp == usize::MAX {
                        //this If was previously matched with an else already, it is already backpatched!
                        return Err(ValidationError::ElseWithoutMatchingIf);
                    }
                    let stp_here = sidetable.len();
                    sidetable.push(SidetableEntry {
                        delta_pc: wasm.pc as isize,
                        delta_stp: stp_here as isize,
                        popcnt: 0,
                        valcnt: block_ty.returns.valtypes.len(),
                    });
                    stps_to_backpatch.push(stp_here);

                    sidetable[*stp].delta_pc = wasm.pc as isize - sidetable[*stp].delta_pc;
                    sidetable[*stp].delta_stp =
                        sidetable.len() as isize - sidetable[*stp].delta_stp;

                    *stp = usize::MAX; // mark this If as backpatched

                    for valtype in block_ty.returns.valtypes.iter().rev() {
                        stack.assert_pop_val_type(*valtype)?;
                    }

                    for valtype in block_ty.params.valtypes.iter() {
                        stack.push_valtype(*valtype);
                    }
                    // The types are explicitly popped and pushed in
                    // https://webassembly.github.io/spec/core/appendix/algorithm.html
                    // therefore types on the stack might change.
                    stack.assert_push_ctrl(label_info, block_ty, true)?;
                } else {
                    return Err(ValidationError::ElseWithoutMatchingIf);
                }
            }
            BR => {
                let label_idx = wasm.read_var_u32()? as LabelIdx;
                validate_branch_and_generate_sidetable_entry(
                    wasm, label_idx, stack, sidetable, false,
                )?;
                stack.make_unspecified()?;
            }
            BR_IF => {
                let label_idx = wasm.read_var_u32()? as LabelIdx;
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                // The types are explicitly popped and pushed in
                // https://webassembly.github.io/spec/core/appendix/algorithm.html
                // therefore types on the stack might change.
                validate_branch_and_generate_sidetable_entry(
                    wasm, label_idx, stack, sidetable, true,
                )?;
            }
            BR_TABLE => {
                let label_vec = wasm.read_vec(|wasm| wasm.read_var_u32().map(|v| v as LabelIdx))?;
                let max_label_idx = wasm.read_var_u32()? as LabelIdx;
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                for label_idx in &label_vec {
                    validate_branch_and_generate_sidetable_entry(
                        wasm, *label_idx, stack, sidetable, false,
                    )?;
                }

                validate_branch_and_generate_sidetable_entry(
                    wasm,
                    max_label_idx,
                    stack,
                    sidetable,
                    false,
                )?;

                // The label arity of the branches must be explicitly checked against each other further
                // if their arities are the same, then they must unify, as they unify against the stack variables already
                // If the following check is not made, the algorithm incorrectly unifies label types with different arities
                // in which the smaller arity type is a suffix in the label type list of the larger arity function

                // stack includes all labels, that check is made in the above fn already
                let max_label_arity = stack
                    .ctrl_stack
                    .get(stack.ctrl_stack.len() - max_label_idx - 1)
                    .unwrap()
                    .label_types()
                    .len();
                for label_idx in &label_vec {
                    let label_arity = stack
                        .ctrl_stack
                        .get(stack.ctrl_stack.len() - *label_idx - 1)
                        .unwrap()
                        .label_types()
                        .len();
                    if max_label_arity != label_arity {
                        return Err(ValidationError::InvalidLabelIdx(*label_idx));
                    }
                }

                stack.make_unspecified()?;
            }
            END => {
                // The types are explicitly popped and pushed in
                // https://webassembly.github.io/spec/core/appendix/algorithm.html
                // therefore types on the stack might change.
                let (label_info, block_ty) = stack.assert_pop_ctrl(true)?;
                let stp_here = sidetable.len();

                match label_info {
                    LabelInfo::Block { stps_to_backpatch } => {
                        stps_to_backpatch.iter().for_each(|i| {
                            sidetable[*i].delta_pc = (wasm.pc as isize) - sidetable[*i].delta_pc;
                            sidetable[*i].delta_stp = (stp_here as isize) - sidetable[*i].delta_stp;
                        });
                    }
                    LabelInfo::If {
                        stp,
                        stps_to_backpatch,
                    } => {
                        if stp != usize::MAX {
                            //This If is still not backpatched, meaning it does not have a corresponding
                            //ELSE. This is only allowed when the corresponding If block has the same input
                            //types as its output types (an untyped ELSE block with no instruction is valid
                            //if and only if it is of this type)
                            if !(block_ty.params == block_ty.returns) {
                                return Err(ValidationError::IfWithoutMatchingElse);
                            }

                            //This If is still not backpatched, meaning it does not have a corresponding
                            //ELSE. Therefore if its condition fails, it jumps after END.
                            sidetable[stp].delta_pc = (wasm.pc as isize) - sidetable[stp].delta_pc;
                            sidetable[stp].delta_stp =
                                (stp_here as isize) - sidetable[stp].delta_stp;
                        }
                        stps_to_backpatch.iter().for_each(|i| {
                            sidetable[*i].delta_pc = (wasm.pc as isize) - sidetable[*i].delta_pc;
                            sidetable[*i].delta_stp = (stp_here as isize) - sidetable[*i].delta_stp;
                        });
                    }
                    LabelInfo::Loop { .. } => (),
                    LabelInfo::Func { stps_to_backpatch } => {
                        // same as blocks, except jump just before the end instr, not after it
                        // the last end instruction will handle the return to callee during execution
                        stps_to_backpatch.iter().for_each(|i| {
                            sidetable[*i].delta_pc =
                                (wasm.pc as isize) - sidetable[*i].delta_pc - 1; // minus 1 is important! TODO: Why?
                            sidetable[*i].delta_stp = (stp_here as isize) - sidetable[*i].delta_stp;
                        });
                    }
                    LabelInfo::Untyped => unreachable!("this label is for untyped wasm sequences"),
                }

                if stack.ctrl_stack.is_empty() {
                    return Ok(());
                }
            }
            RETURN => {
                let label_idx = stack.ctrl_stack.len() - 1; // return behaves the same as br <most_outer>
                validate_branch_and_generate_sidetable_entry(
                    wasm, label_idx, stack, sidetable, false,
                )?;
                stack.make_unspecified()?;
            }
            // call [t1*] -> [t2*]
            CALL => {
                let func_idx = wasm.read_var_u32()? as FuncIdx;
                let type_idx = *type_idx_of_fn
                    .get(func_idx)
                    .ok_or(ValidationError::FunctionIsNotDefined(func_idx))?;
                let func_ty = &fn_types[type_idx];

                for typ in func_ty.params.valtypes.iter().rev() {
                    stack.assert_pop_val_type(*typ)?;
                }

                for typ in func_ty.returns.valtypes.iter() {
                    stack.push_valtype(*typ);
                }
            }
            CALL_INDIRECT => {
                let type_idx = wasm.read_var_u32()? as TypeIdx;

                let table_idx = wasm.read_var_u32()? as TableIdx;

                let tab = tables
                    .get(table_idx)
                    .ok_or(ValidationError::TableIsNotDefined(table_idx))?;

                if tab.et != RefType::FuncRef {
                    return Err(ValidationError::WrongRefTypeForInteropValue(
                        tab.et,
                        RefType::FuncRef,
                    ));
                }

                let func_ty = fn_types
                    .get(type_idx)
                    .ok_or(ValidationError::InvalidTypeIdx(type_idx))?;

                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;

                for typ in func_ty.params.valtypes.iter().rev() {
                    stack.assert_pop_val_type(*typ)?;
                }

                for typ in func_ty.returns.valtypes.iter() {
                    stack.push_valtype(*typ);
                }
            }
            // unreachable: [t1*] -> [t2*]
            UNREACHABLE => {
                stack.make_unspecified()?;
            }
            DROP => {
                stack.drop_val()?;
            }
            SELECT => {
                stack.validate_polymorphic_select()?;
            }
            SELECT_T => {
                let type_vec = wasm.read_vec(ValType::read)?;
                if type_vec.len() != 1 {
                    return Err(ValidationError::InvalidSelectTypeVector);
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.assert_pop_val_type(type_vec[0])?;
                stack.assert_pop_val_type(type_vec[0])?;
                stack.push_valtype(type_vec[0]);
            }
            // local.get: [] -> [t]
            LOCAL_GET => {
                let local_idx = wasm.read_var_u32()? as LocalIdx;
                let local_ty = locals
                    .get(local_idx)
                    .ok_or(ValidationError::InvalidLocalIdx)?;
                stack.push_valtype(*local_ty);
            }
            // local.set [t] -> []
            LOCAL_SET => {
                let local_idx = wasm.read_var_u32()? as LocalIdx;
                let local_ty = locals
                    .get(local_idx)
                    .ok_or(ValidationError::InvalidLocalIdx)?;
                stack.assert_pop_val_type(*local_ty)?;
            }
            // local.set [t] -> [t]
            LOCAL_TEE => {
                let local_idx = wasm.read_var_u32()? as LocalIdx;
                let local_ty = locals
                    .get(local_idx)
                    .ok_or(ValidationError::InvalidLocalIdx)?;
                stack.assert_val_types_on_top(&[*local_ty], true)?;
            }
            // global.get [] -> [t]
            GLOBAL_GET => {
                let global_idx = wasm.read_var_u32()? as GlobalIdx;
                let global = globals
                    .get(global_idx)
                    .ok_or(ValidationError::InvalidGlobalIdx(global_idx))?;

                stack.push_valtype(global.ty.ty);
                trace!(
                    "Instruction: global.get '{}' [] -> [{:?}]",
                    global_idx,
                    // global,
                    global.ty.ty
                );
            }
            // global.set [t] -> []
            GLOBAL_SET => {
                let global_idx = wasm.read_var_u32()? as GlobalIdx;
                let global = globals
                    .get(global_idx)
                    .ok_or(ValidationError::InvalidGlobalIdx(global_idx))?;

                if !global.ty.is_mut {
                    return Err(ValidationError::GlobalIsConst);
                }

                stack.assert_pop_val_type(global.ty.ty)?;
            }
            TABLE_GET => {
                let table_idx = wasm.read_var_u32()? as TableIdx;

                if tables.len() <= table_idx {
                    return Err(ValidationError::TableIsNotDefined(table_idx));
                }

                let t = tables.get(table_idx).unwrap().et;

                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::RefType(t));
            }
            TABLE_SET => {
                let table_idx = wasm.read_var_u32()? as TableIdx;

                if tables.len() <= table_idx {
                    return Err(ValidationError::TableIsNotDefined(table_idx));
                }

                let t = tables.get(table_idx).unwrap().et;

                stack.assert_pop_ref_type(Some(t))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
            }
            I32_LOAD => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 2 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 2));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            I64_LOAD => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 3 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 3));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::NumType(NumType::I64));
            }
            F32_LOAD => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 2 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 2));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::NumType(NumType::F32));
            }
            F64_LOAD => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 3 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 3));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::NumType(NumType::F64));
            }
            I32_LOAD8_S => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 0 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 0));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            I32_LOAD8_U => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 0 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 0));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            I32_LOAD16_S => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 1 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 1));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            I32_LOAD16_U => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 1 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 1));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            I64_LOAD8_S => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 0 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 0));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::NumType(NumType::I64));
            }
            I64_LOAD8_U => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 0 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 0));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::NumType(NumType::I64));
            }
            I64_LOAD16_S => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 1 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 1));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::NumType(NumType::I64));
            }
            I64_LOAD16_U => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 1 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 1));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::NumType(NumType::I64));
            }
            I64_LOAD32_S => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 2 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 2));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::NumType(NumType::I64));
            }
            I64_LOAD32_U => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 2 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 2));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::NumType(NumType::I64));
            }
            I32_STORE => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 2 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 2));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
            }
            I64_STORE => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 3 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 3));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
            }
            F32_STORE => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 2 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 2));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::F32))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
            }
            F64_STORE => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 3 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 3));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::F64))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
            }
            I32_STORE8 => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 0 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 0));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
            }
            I32_STORE16 => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 1 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 1));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
            }
            I64_STORE8 => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 0 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 0));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
            }
            I64_STORE16 => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 1 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 1));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
            }
            I64_STORE32 => {
                if memories.is_empty() {
                    return Err(ValidationError::MemoryIsNotDefined(0));
                }
                let memarg = MemArg::read(wasm)?;
                if memarg.align > 2 {
                    return Err(ValidationError::ErroneousAlignment(memarg.align, 2));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
            }
            MEMORY_SIZE => {
                let mem_idx = wasm.read_u8()? as MemIdx;
                if mem_idx != 0 {
                    return Err(ValidationError::UnsupportedMultipleMemoriesProposal);
                }
                if memories.len() <= mem_idx {
                    return Err(ValidationError::MemoryIsNotDefined(mem_idx));
                }
                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            MEMORY_GROW => {
                let mem_idx = wasm.read_u8()? as MemIdx;
                if mem_idx != 0 {
                    return Err(ValidationError::UnsupportedMultipleMemoriesProposal);
                }
                if memories.len() <= mem_idx {
                    return Err(ValidationError::MemoryIsNotDefined(mem_idx));
                }
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            // i32.const: [] -> [i32]
            I32_CONST => {
                let _num = wasm.read_var_i32()?;
                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            I64_CONST => {
                let _num = wasm.read_var_i64()?;
                stack.push_valtype(ValType::NumType(NumType::I64));
            }
            F32_CONST => {
                let _num = wasm.read_var_f32()?;
                stack.push_valtype(ValType::NumType(NumType::F32));
            }
            F64_CONST => {
                let _num = wasm.read_var_f64()?;
                stack.push_valtype(ValType::NumType(NumType::F64));
            }
            I32_EQZ => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;

                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            I32_EQ | I32_NE | I32_LT_S | I32_LT_U | I32_GT_S | I32_GT_U | I32_LE_S | I32_LE_U
            | I32_GE_S | I32_GE_U => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;

                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            I64_EQZ => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;

                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            I64_EQ | I64_NE | I64_LT_S | I64_LT_U | I64_GT_S | I64_GT_U | I64_LE_S | I64_LE_U
            | I64_GE_S | I64_GE_U => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;

                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            F32_EQ | F32_NE | F32_LT | F32_GT | F32_LE | F32_GE => {
                stack.assert_pop_val_type(ValType::NumType(NumType::F32))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::F32))?;

                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            F64_EQ | F64_NE | F64_LT | F64_GT | F64_LE | F64_GE => {
                stack.assert_pop_val_type(ValType::NumType(NumType::F64))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::F64))?;

                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            F32_ABS | F32_NEG | F32_CEIL | F32_FLOOR | F32_TRUNC | F32_NEAREST | F32_SQRT => {
                stack.assert_pop_val_type(ValType::NumType(NumType::F32))?;

                stack.push_valtype(ValType::NumType(NumType::F32));
            }
            F32_ADD | F32_SUB | F32_MUL | F32_DIV | F32_MIN | F32_MAX | F32_COPYSIGN => {
                stack.assert_pop_val_type(ValType::NumType(NumType::F32))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::F32))?;

                stack.push_valtype(ValType::NumType(NumType::F32));
            }
            F64_ABS | F64_NEG | F64_CEIL | F64_FLOOR | F64_TRUNC | F64_NEAREST | F64_SQRT => {
                stack.assert_pop_val_type(ValType::NumType(NumType::F64))?;

                stack.push_valtype(ValType::NumType(NumType::F64));
            }
            F64_ADD | F64_SUB | F64_MUL | F64_DIV | F64_MIN | F64_MAX | F64_COPYSIGN => {
                stack.assert_pop_val_type(ValType::NumType(NumType::F64))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::F64))?;

                stack.push_valtype(ValType::NumType(NumType::F64));
            }
            I32_ADD | I32_SUB | I32_MUL | I32_DIV_S | I32_DIV_U | I32_REM_S => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;

                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            // i32.clz: [i32] -> [i32]
            I32_CLZ | I32_CTZ | I32_POPCNT => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;

                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            I32_REM_U | I32_AND | I32_OR | I32_XOR | I32_SHL | I32_SHR_S | I32_SHR_U | I32_ROTL
            | I32_ROTR => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;

                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            I64_CLZ | I64_CTZ | I64_POPCNT => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;

                stack.push_valtype(ValType::NumType(NumType::I64));
            }

            I64_ADD | I64_SUB | I64_MUL | I64_DIV_S | I64_DIV_U | I64_REM_S | I64_REM_U
            | I64_AND | I64_OR | I64_XOR | I64_SHL | I64_SHR_S | I64_SHR_U | I64_ROTL
            | I64_ROTR => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;

                stack.push_valtype(ValType::NumType(NumType::I64));
            }

            I32_WRAP_I64 => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;

                stack.push_valtype(ValType::NumType(NumType::I32));
            }

            I32_TRUNC_F32_S | I32_TRUNC_F32_U | I32_REINTERPRET_F32 => {
                stack.assert_pop_val_type(ValType::NumType(NumType::F32))?;

                stack.push_valtype(ValType::NumType(NumType::I32));
            }

            I32_TRUNC_F64_S | I32_TRUNC_F64_U => {
                stack.assert_pop_val_type(ValType::NumType(NumType::F64))?;

                stack.push_valtype(ValType::NumType(NumType::I32));
            }

            I64_EXTEND_I32_S | I64_EXTEND_I32_U => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;

                stack.push_valtype(ValType::NumType(NumType::I64));
            }

            I64_TRUNC_F32_S | I64_TRUNC_F32_U => {
                stack.assert_pop_val_type(ValType::NumType(NumType::F32))?;

                stack.push_valtype(ValType::NumType(NumType::I64));
            }

            I64_TRUNC_F64_S | I64_TRUNC_F64_U | I64_REINTERPRET_F64 => {
                stack.assert_pop_val_type(ValType::NumType(NumType::F64))?;

                stack.push_valtype(ValType::NumType(NumType::I64));
            }

            F32_CONVERT_I32_S | F32_CONVERT_I32_U | F32_REINTERPRET_I32 => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;

                stack.push_valtype(ValType::NumType(NumType::F32));
            }

            F32_CONVERT_I64_S | F32_CONVERT_I64_U => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;

                stack.push_valtype(ValType::NumType(NumType::F32));
            }

            F32_DEMOTE_F64 => {
                stack.assert_pop_val_type(ValType::NumType(NumType::F64))?;

                stack.push_valtype(ValType::NumType(NumType::F32));
            }

            F64_CONVERT_I32_S | F64_CONVERT_I32_U => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;

                stack.push_valtype(ValType::NumType(NumType::F64));
            }

            F64_CONVERT_I64_S | F64_CONVERT_I64_U | F64_REINTERPRET_I64 => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;

                stack.push_valtype(ValType::NumType(NumType::F64));
            }

            F64_PROMOTE_F32 => {
                stack.assert_pop_val_type(ValType::NumType(NumType::F32))?;

                stack.push_valtype(ValType::NumType(NumType::F64));
            }

            REF_NULL => {
                let reftype = RefType::read(wasm)?;
                // at validation-time we don't really care if it's null or not
                stack.push_valtype(ValType::RefType(reftype));
            }

            REF_IS_NULL => {
                stack.assert_pop_ref_type(None)?;
                stack.push_valtype(ValType::NumType(NumType::I32));
            }

            REF_FUNC => {
                let func_idx = wasm.read_var_u32()? as FuncIdx;

                // checking for existence suffices for checking whether this function has a valid type.
                if type_idx_of_fn.len() <= func_idx {
                    return Err(ValidationError::FunctionIsNotDefined(func_idx));
                }

                // check whether func_idx is in C.refs
                // https://webassembly.github.io/spec/core/valid/conventions.html#context
                if !validation_context_refs.contains(&func_idx) {
                    return Err(ValidationError::ReferencingAnUnreferencedFunction(func_idx));
                }

                stack.push_valtype(ValType::RefType(RefType::FuncRef));
            }

            FC_EXTENSIONS => {
                let Ok(second_instr) = wasm.read_var_u32() else {
                    // TODO only do this if EOF
                    return Err(ValidationError::ExprMissingEnd);
                };

                #[cfg(debug_assertions)]
                crate::core::utils::print_beautiful_fc_extension(second_instr, wasm.pc);

                #[cfg(not(debug_assertions))]
                trace!(
                    "Read instruction byte {second_instr} at wasm_binary[{}]",
                    wasm.pc
                );

                use crate::core::reader::types::opcode::fc_extensions::*;
                match second_instr {
                    I32_TRUNC_SAT_F32_S => {
                        stack.assert_pop_val_type(ValType::NumType(NumType::F32))?;
                        stack.push_valtype(ValType::NumType(NumType::I32));
                    }
                    I32_TRUNC_SAT_F32_U => {
                        stack.assert_pop_val_type(ValType::NumType(NumType::F32))?;
                        stack.push_valtype(ValType::NumType(NumType::I32));
                    }
                    I32_TRUNC_SAT_F64_S => {
                        stack.assert_pop_val_type(ValType::NumType(NumType::F64))?;
                        stack.push_valtype(ValType::NumType(NumType::I32));
                    }
                    I32_TRUNC_SAT_F64_U => {
                        stack.assert_pop_val_type(ValType::NumType(NumType::F64))?;
                        stack.push_valtype(ValType::NumType(NumType::I32));
                    }
                    I64_TRUNC_SAT_F32_S => {
                        stack.assert_pop_val_type(ValType::NumType(NumType::F32))?;
                        stack.push_valtype(ValType::NumType(NumType::I64));
                    }
                    I64_TRUNC_SAT_F32_U => {
                        stack.assert_pop_val_type(ValType::NumType(NumType::F32))?;
                        stack.push_valtype(ValType::NumType(NumType::I64));
                    }
                    I64_TRUNC_SAT_F64_S => {
                        stack.assert_pop_val_type(ValType::NumType(NumType::F64))?;
                        stack.push_valtype(ValType::NumType(NumType::I64));
                    }
                    I64_TRUNC_SAT_F64_U => {
                        stack.assert_pop_val_type(ValType::NumType(NumType::F64))?;
                        stack.push_valtype(ValType::NumType(NumType::I64));
                    }
                    MEMORY_INIT => {
                        let data_idx = wasm.read_var_u32()? as DataIdx;
                        let mem_idx = wasm.read_u8()? as MemIdx;
                        if mem_idx != 0 {
                            return Err(ValidationError::UnsupportedMultipleMemoriesProposal);
                        }
                        if memories.len() <= mem_idx {
                            return Err(ValidationError::MemoryIsNotDefined(mem_idx));
                        }
                        if data_count.is_none() {
                            return Err(ValidationError::NoDataSegments);
                        }
                        if data_count.unwrap() as usize <= data_idx {
                            return Err(ValidationError::DataSegmentNotFound(data_idx));
                        }
                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                    }
                    DATA_DROP => {
                        if data_count.is_none() {
                            return Err(ValidationError::NoDataSegments);
                        }
                        let data_idx = wasm.read_var_u32()? as DataIdx;
                        if data_count.unwrap() as usize <= data_idx {
                            return Err(ValidationError::DataSegmentNotFound(data_idx));
                        }
                    }
                    MEMORY_COPY => {
                        let (dst, src) = (wasm.read_u8()? as usize, wasm.read_u8()? as usize);
                        if dst != 0 || src != 0 {
                            return Err(ValidationError::UnsupportedMultipleMemoriesProposal);
                        }
                        if memories.is_empty() {
                            return Err(ValidationError::MemoryIsNotDefined(0));
                        }
                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                    }
                    MEMORY_FILL => {
                        let mem_idx = wasm.read_u8()? as MemIdx;
                        if mem_idx != 0 {
                            return Err(ValidationError::UnsupportedMultipleMemoriesProposal);
                        }
                        if memories.len() <= mem_idx {
                            return Err(ValidationError::MemoryIsNotDefined(mem_idx));
                        }
                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                    }
                    TABLE_INIT => {
                        let elem_idx = wasm.read_var_u32()? as ElemIdx;
                        let table_idx = wasm.read_var_u32()? as TableIdx;

                        if tables.len() <= table_idx {
                            return Err(ValidationError::TableIsNotDefined(table_idx));
                        }

                        let t1 = tables[table_idx].et;

                        if elements.len() <= elem_idx {
                            return Err(ValidationError::ElementIsNotDefined(elem_idx));
                        }

                        let t2 = elements[elem_idx].to_ref_type();

                        if t1 != t2 {
                            return Err(ValidationError::DifferentRefTypes(t1, t2));
                        }
                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                        // INFO: wasmtime checks for this value to be an index in the tables array, interesting
                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                    }
                    ELEM_DROP => {
                        let elem_idx = wasm.read_var_u32()? as ElemIdx;

                        if elements.len() <= elem_idx {
                            return Err(ValidationError::ElementIsNotDefined(elem_idx));
                        }
                    }
                    TABLE_COPY => {
                        let table_x_idx = wasm.read_var_u32()? as TableIdx;
                        let table_y_idx = wasm.read_var_u32()? as TableIdx;

                        if tables.len() <= table_x_idx {
                            return Err(ValidationError::TableIsNotDefined(table_x_idx));
                        }

                        if tables.len() <= table_y_idx {
                            return Err(ValidationError::TableIsNotDefined(table_y_idx));
                        }

                        let t1 = tables[table_x_idx].et;
                        let t2 = tables[table_y_idx].et;

                        if t1 != t2 {
                            return Err(ValidationError::DifferentRefTypes(t1, t2));
                        }

                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                    }
                    TABLE_GROW => {
                        let table_idx = wasm.read_var_u32()? as TableIdx;

                        if tables.len() <= table_idx {
                            return Err(ValidationError::TableIsNotDefined(table_idx));
                        }

                        let t = tables[table_idx].et;

                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                        stack.assert_pop_ref_type(Some(t))?;

                        stack.push_valtype(ValType::NumType(NumType::I32));
                    }
                    TABLE_SIZE => {
                        let table_idx = wasm.read_var_u32()? as TableIdx;

                        if tables.len() <= table_idx {
                            return Err(ValidationError::TableIsNotDefined(table_idx));
                        }

                        stack.push_valtype(ValType::NumType(NumType::I32));
                    }
                    TABLE_FILL => {
                        let table_idx = wasm.read_var_u32()? as TableIdx;

                        if tables.len() <= table_idx {
                            return Err(ValidationError::TableIsNotDefined(table_idx));
                        }

                        let t = tables[table_idx].et;

                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                        stack.assert_pop_ref_type(Some(t))?;
                        stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;
                    }
                    _ => {
                        return Err(ValidationError::InvalidMultiByteInstr(
                            first_instr_byte,
                            second_instr,
                        ))
                    }
                }
            }

            I32_EXTEND8_S => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;

                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            I32_EXTEND16_S => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I32))?;

                stack.push_valtype(ValType::NumType(NumType::I32));
            }
            I64_EXTEND8_S => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;

                stack.push_valtype(ValType::NumType(NumType::I64));
            }
            I64_EXTEND16_S => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;

                stack.push_valtype(ValType::NumType(NumType::I64));
            }
            I64_EXTEND32_S => {
                stack.assert_pop_val_type(ValType::NumType(NumType::I64))?;

                stack.push_valtype(ValType::NumType(NumType::I64));
            }

            // Unimplemented or invalid instructions
            0x06..=0x0A
            | 0x12..=0x19
            | 0x1C..=0x1F
            | 0x25..=0x27
            | 0xC0..=0xFA
            | 0xFB
            | 0xFD
            | 0xFE
            | 0xFF => {
                return Err(ValidationError::InvalidInstr(first_instr_byte));
            }
        }
    }
}
