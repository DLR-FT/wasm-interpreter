/*
# This file incorporates code from the WebAssembly testsuite, originally
# available at https://github.com/WebAssembly/testsuite.
#
# The original code is licensed under the Apache License, Version 2.0
# (the "License"); you may not use this file except in compliance
# with the License. You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
*/
use wasm::{validate, RuntimeError, RuntimeInstance};

macro_rules! get_func {
    ($instance:ident, $func_name:expr) => {
        &$instance.get_function_by_name("", $func_name).unwrap()
    };
}

macro_rules! assert_result {
    ($instance:expr, $func_name:expr, $arg:expr, $result:expr) => {
        assert_eq!($result, $instance.invoke($func_name, $arg).unwrap());
    };
}

#[test_log::test]
fn memory_copy_test_1() {
    let w = r#"
    (module
        (memory (export "memory0") 1 1)
        (data (i32.const 2) "\03\01\04\01")
        (data (i32.const 12) "\07\05\02\03\06")
        (func (export "test")
            (nop))
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let test = get_func!(i, "test");
    i.invoke::<(), ()>(test, ()).unwrap();

    let load8_u = get_func!(i, "load8_u");
    let results = Vec::from([
        0, 0, 3, 1, 4, 1, 0, 0, 0, 0, 0, 0, 7, 5, 2, 3, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ]);
    for j in 0..30 {
        assert_result!(i, load8_u, j as i32, results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_2() {
    let w = r#"
    (module
        (memory (export "memory0") 1 1)
        (data (i32.const 2) "\03\01\04\01")
        (data (i32.const 12) "\07\05\02\03\06")
        (func (export "test")
            (memory.copy (i32.const 13) (i32.const 2) (i32.const 3))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let test = get_func!(i, "test");
    i.invoke::<(), ()>(test, ()).unwrap();

    let load8_u = get_func!(i, "load8_u");
    let results = Vec::from([
        0, 0, 3, 1, 4, 1, 0, 0, 0, 0, 0, 0, 7, 3, 1, 4, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ]);
    for j in 0..30 {
        assert_result!(i, load8_u, j as i32, results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_3() {
    let w = r#"
    (module
        (memory (export "memory0") 1 1)
        (data (i32.const 2) "\03\01\04\01")
        (data (i32.const 12) "\07\05\02\03\06")
        (func (export "test")
            (memory.copy (i32.const 25) (i32.const 15) (i32.const 2))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let test = get_func!(i, "test");
    i.invoke::<(), ()>(test, ()).unwrap();

    let load8_u = get_func!(i, "load8_u");
    let offsets = Vec::from([
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
        25, 26, 27, 28, 29,
    ]);
    let results = Vec::from([
        0, 0, 3, 1, 4, 1, 0, 0, 0, 0, 0, 0, 7, 5, 2, 3, 6, 0, 0, 0, 0, 0, 0, 0, 0, 3, 6, 0, 0, 0,
    ]);
    for j in 0..offsets.len() {
        assert_result!(i, load8_u, offsets[j], results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_4() {
    let w = r#"
    (module
        (memory (export "memory0") 1 1)
        (data (i32.const 2) "\03\01\04\01")
        (data (i32.const 12) "\07\05\02\03\06")
        (func (export "test")
            (memory.copy (i32.const 13) (i32.const 25) (i32.const 3))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let test = get_func!(i, "test");
    i.invoke::<(), ()>(test, ()).unwrap();

    let load8_u = get_func!(i, "load8_u");
    let offsets = Vec::from([
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
        25, 26, 27, 28, 29,
    ]);
    let results = Vec::from([
        0, 0, 3, 1, 4, 1, 0, 0, 0, 0, 0, 0, 7, 0, 0, 0, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ]);
    for j in 0..offsets.len() {
        assert_result!(i, load8_u, offsets[j], results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_5() {
    let w = r#"
    (module
        (memory (export "memory0") 1 1)
        (data (i32.const 2) "\03\01\04\01")
        (data (i32.const 12) "\07\05\02\03\06")
        (func (export "test")
            (memory.copy (i32.const 10) (i32.const 12) (i32.const 7))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let test = get_func!(i, "test");
    i.invoke::<(), ()>(test, ()).unwrap();

    let load8_u = get_func!(i, "load8_u");
    let offsets = Vec::from([
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,
        25, 26, 27, 28, 29,
    ]);
    let results = Vec::from([
        0, 0, 3, 1, 4, 1, 0, 0, 0, 0, 7, 5, 2, 3, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ]);
    for j in 0..offsets.len() {
        assert_result!(i, load8_u, offsets[j], results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_6() {
    let w = r#"
    (module
        (memory (export "mem") 1 1 )
        (data (i32.const 0) "\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13")
        (func (export "run") (param $targetOffs i32) (param $srcOffs i32) (param $len i32)
            (memory.copy (local.get $targetOffs) (local.get $srcOffs) (local.get $len))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let run = get_func!(i, "run");
    let err = i.invoke::<(i32, i32, i32), ()>(run, (65516, 0, 40));
    if err.is_err() {
        assert!(err.unwrap_err() == RuntimeError::MemoryAccessOutOfBounds);
    }

    let load8_u = get_func!(i, "load8_u");
    let offsets = Vec::from([
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 218, 417, 616, 815,
        1014, 1213, 1412, 1611, 1810, 2009, 2208, 2407, 2606, 2805, 3004, 3203, 3402, 3601, 3800,
        3999, 4198, 4397, 4596, 4795, 4994, 5193, 5392, 5591, 5790, 5989, 6188, 6387, 6586, 6785,
        6984, 7183, 7382, 7581, 7780, 7979, 8178, 8377, 8576, 8775, 8974, 9173, 9372, 9571, 9770,
        9969, 10168, 10367, 10566, 10765, 10964, 11163, 11362, 11561, 11760, 11959, 12158, 12357,
        12556, 12755, 12954, 13153, 13352, 13551, 13750, 13949, 14148, 14347, 14546, 14745, 14944,
        15143, 15342, 15541, 15740, 15939, 16138, 16337, 16536, 16735, 16934, 17133, 17332, 17531,
        17730, 17929, 18128, 18327, 18526, 18725, 18924, 19123, 19322, 19521, 19720, 19919, 20118,
        20317, 20516, 20715, 20914, 21113, 21312, 21511, 21710, 21909, 22108, 22307, 22506, 22705,
        22904, 23103, 23302, 23501, 23700, 23899, 24098, 24297, 24496, 24695, 24894, 25093, 25292,
        25491, 25690, 25889, 26088, 26287, 26486, 26685, 26884, 27083, 27282, 27481, 27680, 27879,
        28078, 28277, 28476, 28675, 28874, 29073, 29272, 29471, 29670, 29869, 30068, 30267, 30466,
        30665, 30864, 31063, 31262, 31461, 31660, 31859, 32058, 32257, 32456, 32655, 32854, 33053,
        33252, 33451, 33650, 33849, 34048, 34247, 34446, 34645, 34844, 35043, 35242, 35441, 35640,
        35839, 36038, 36237, 36436, 36635, 36834, 37033, 37232, 37431, 37630, 37829, 38028, 38227,
        38426, 38625, 38824, 39023, 39222, 39421, 39620, 39819, 40018, 40217, 40416, 40615, 40814,
        41013, 41212, 41411, 41610, 41809, 42008, 42207, 42406, 42605, 42804, 43003, 43202, 43401,
        43600, 43799, 43998, 44197, 44396, 44595, 44794, 44993, 45192, 45391, 45590, 45789, 45988,
        46187, 46386, 46585, 46784, 46983, 47182, 47381, 47580, 47779, 47978, 48177, 48376, 48575,
        48774, 48973, 49172, 49371, 49570, 49769, 49968, 50167, 50366, 50565, 50764, 50963, 51162,
        51361, 51560, 51759, 51958, 52157, 52356, 52555, 52754, 52953, 53152, 53351, 53550, 53749,
        53948, 54147, 54346, 54545, 54744, 54943, 55142, 55341, 55540, 55739, 55938, 56137, 56336,
        56535, 56734, 56933, 57132, 57331, 57530, 57729, 57928, 58127, 58326, 58525, 58724, 58923,
        59122, 59321, 59520, 59719, 59918, 60117, 60316, 60515, 60714, 60913, 61112, 61311, 61510,
        61709, 61908, 62107, 62306, 62505, 62704, 62903, 63102, 63301, 63500, 63699, 63898, 64097,
        64296, 64495, 64694, 64893, 65092, 65291, 65490,
    ]);
    let results = Vec::from([
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ]);
    for j in 0..offsets.len() {
        assert_result!(i, load8_u, offsets[j], results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_7() {
    let w = r#"
    (module
        (memory (export "mem") 1 1 )
        (data (i32.const 0) "\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13\14")
        (func (export "run") (param $targetOffs i32) (param $srcOffs i32) (param $len i32)
            (memory.copy (local.get $targetOffs) (local.get $srcOffs) (local.get $len))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let run = get_func!(i, "run");
    let err = i.invoke::<(i32, i32, i32), ()>(run, (65515, 0, 39));
    if err.is_err() {
        assert!(err.unwrap_err() == RuntimeError::MemoryAccessOutOfBounds);
    }

    let load8_u = get_func!(i, "load8_u");
    let offsets = Vec::from([
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 219, 418, 617,
        816, 1015, 1214, 1413, 1612, 1811, 2010, 2209, 2408, 2607, 2806, 3005, 3204, 3403, 3602,
        3801, 4000, 4199, 4398, 4597, 4796, 4995, 5194, 5393, 5592, 5791, 5990, 6189, 6388, 6587,
        6786, 6985, 7184, 7383, 7582, 7781, 7980, 8179, 8378, 8577, 8776, 8975, 9174, 9373, 9572,
        9771, 9970, 10169, 10368, 10567, 10766, 10965, 11164, 11363, 11562, 11761, 11960, 12159,
        12358, 12557, 12756, 12955, 13154, 13353, 13552, 13751, 13950, 14149, 14348, 14547, 14746,
        14945, 15144, 15343, 15542, 15741, 15940, 16139, 16338, 16537, 16736, 16935, 17134, 17333,
        17532, 17731, 17930, 18129, 18328, 18527, 18726, 18925, 19124, 19323, 19522, 19721, 19920,
        20119, 20318, 20517, 20716, 20915, 21114, 21313, 21512, 21711, 21910, 22109, 22308, 22507,
        22706, 22905, 23104, 23303, 23502, 23701, 23900, 24099, 24298, 24497, 24696, 24895, 25094,
        25293, 25492, 25691, 25890, 26089, 26288, 26487, 26686, 26885, 27084, 27283, 27482, 27681,
        27880, 28079, 28278, 28477, 28676, 28875, 29074, 29273, 29472, 29671, 29870, 30069, 30268,
        30467, 30666, 30865, 31064, 31263, 31462, 31661, 31860, 32059, 32258, 32457, 32656, 32855,
        33054, 33253, 33452, 33651, 33850, 34049, 34248, 34447, 34646, 34845, 35044, 35243, 35442,
        35641, 35840, 36039, 36238, 36437, 36636, 36835, 37034, 37233, 37432, 37631, 37830, 38029,
        38228, 38427, 38626, 38825, 39024, 39223, 39422, 39621, 39820, 40019, 40218, 40417, 40616,
        40815, 41014, 41213, 41412, 41611, 41810, 42009, 42208, 42407, 42606, 42805, 43004, 43203,
        43402, 43601, 43800, 43999, 44198, 44397, 44596, 44795, 44994, 45193, 45392, 45591, 45790,
        45989, 46188, 46387, 46586, 46785, 46984, 47183, 47382, 47581, 47780, 47979, 48178, 48377,
        48576, 48775, 48974, 49173, 49372, 49571, 49770, 49969, 50168, 50367, 50566, 50765, 50964,
        51163, 51362, 51561, 51760, 51959, 52158, 52357, 52556, 52755, 52954, 53153, 53352, 53551,
        53750, 53949, 54148, 54347, 54546, 54745, 54944, 55143, 55342, 55541, 55740, 55939, 56138,
        56337, 56536, 56735, 56934, 57133, 57332, 57531, 57730, 57929, 58128, 58327, 58526, 58725,
        58924, 59123, 59322, 59521, 59720, 59919, 60118, 60317, 60516, 60715, 60914, 61113, 61312,
        61511, 61710, 61909, 62108, 62307, 62506, 62705, 62904, 63103, 63302, 63501, 63700, 63899,
        64098, 64297, 64496, 64695, 64894, 65093, 65292, 65491,
    ]);
    let results = Vec::from([
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ]);
    for j in 0..offsets.len() {
        assert_result!(i, load8_u, offsets[j], results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_8() {
    let w = r#"
    (module
        (memory (export "mem") 1 1 )
        (data (i32.const 0) "\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13\14")
        (func (export "run") (param $targetOffs i32) (param $srcOffs i32) (param $len i32)
            (memory.copy (local.get $targetOffs) (local.get $srcOffs) (local.get $len))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let run = get_func!(i, "run");
    let err = i.invoke::<(i32, i32, i32), ()>(run, (65515, 0, 39));
    if err.is_err() {
        assert!(err.unwrap_err() == RuntimeError::MemoryAccessOutOfBounds);
    }

    let load8_u = get_func!(i, "load8_u");
    let offsets = Vec::from([
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 219, 418, 617,
        816, 1015, 1214, 1413, 1612, 1811, 2010, 2209, 2408, 2607, 2806, 3005, 3204, 3403, 3602,
        3801, 4000, 4199, 4398, 4597, 4796, 4995, 5194, 5393, 5592, 5791, 5990, 6189, 6388, 6587,
        6786, 6985, 7184, 7383, 7582, 7781, 7980, 8179, 8378, 8577, 8776, 8975, 9174, 9373, 9572,
        9771, 9970, 10169, 10368, 10567, 10766, 10965, 11164, 11363, 11562, 11761, 11960, 12159,
        12358, 12557, 12756, 12955, 13154, 13353, 13552, 13751, 13950, 14149, 14348, 14547, 14746,
        14945, 15144, 15343, 15542, 15741, 15940, 16139, 16338, 16537, 16736, 16935, 17134, 17333,
        17532, 17731, 17930, 18129, 18328, 18527, 18726, 18925, 19124, 19323, 19522, 19721, 19920,
        20119, 20318, 20517, 20716, 20915, 21114, 21313, 21512, 21711, 21910, 22109, 22308, 22507,
        22706, 22905, 23104, 23303, 23502, 23701, 23900, 24099, 24298, 24497, 24696, 24895, 25094,
        25293, 25492, 25691, 25890, 26089, 26288, 26487, 26686, 26885, 27084, 27283, 27482, 27681,
        27880, 28079, 28278, 28477, 28676, 28875, 29074, 29273, 29472, 29671, 29870, 30069, 30268,
        30467, 30666, 30865, 31064, 31263, 31462, 31661, 31860, 32059, 32258, 32457, 32656, 32855,
        33054, 33253, 33452, 33651, 33850, 34049, 34248, 34447, 34646, 34845, 35044, 35243, 35442,
        35641, 35840, 36039, 36238, 36437, 36636, 36835, 37034, 37233, 37432, 37631, 37830, 38029,
        38228, 38427, 38626, 38825, 39024, 39223, 39422, 39621, 39820, 40019, 40218, 40417, 40616,
        40815, 41014, 41213, 41412, 41611, 41810, 42009, 42208, 42407, 42606, 42805, 43004, 43203,
        43402, 43601, 43800, 43999, 44198, 44397, 44596, 44795, 44994, 45193, 45392, 45591, 45790,
        45989, 46188, 46387, 46586, 46785, 46984, 47183, 47382, 47581, 47780, 47979, 48178, 48377,
        48576, 48775, 48974, 49173, 49372, 49571, 49770, 49969, 50168, 50367, 50566, 50765, 50964,
        51163, 51362, 51561, 51760, 51959, 52158, 52357, 52556, 52755, 52954, 53153, 53352, 53551,
        53750, 53949, 54148, 54347, 54546, 54745, 54944, 55143, 55342, 55541, 55740, 55939, 56138,
        56337, 56536, 56735, 56934, 57133, 57332, 57531, 57730, 57929, 58128, 58327, 58526, 58725,
        58924, 59123, 59322, 59521, 59720, 59919, 60118, 60317, 60516, 60715, 60914, 61113, 61312,
        61511, 61710, 61909, 62108, 62307, 62506, 62705, 62904, 63103, 63302, 63501, 63700, 63899,
        64098, 64297, 64496, 64695, 64894, 65093, 65292, 65491,
    ]);
    let results = Vec::from([
        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ]);
    for j in 0..offsets.len() {
        assert_result!(i, load8_u, offsets[j], results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_9() {
    let w = r#"
    (module
        (memory (export "mem") 1 1 )
        (data (i32.const 65516) "\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13")
        (func (export "run") (param $targetOffs i32) (param $srcOffs i32) (param $len i32)
            (memory.copy (local.get $targetOffs) (local.get $srcOffs) (local.get $len))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let run = get_func!(i, "run");
    let err = i.invoke::<(i32, i32, i32), ()>(run, (0, 65516, 40));
    if err.is_err() {
        assert!(err.unwrap_err() == RuntimeError::MemoryAccessOutOfBounds);
    }

    let load8_u = get_func!(i, "load8_u");
    let offsets = Vec::from([
        198, 397, 596, 795, 994, 1193, 1392, 1591, 1790, 1989, 2188, 2387, 2586, 2785, 2984, 3183,
        3382, 3581, 3780, 3979, 4178, 4377, 4576, 4775, 4974, 5173, 5372, 5571, 5770, 5969, 6168,
        6367, 6566, 6765, 6964, 7163, 7362, 7561, 7760, 7959, 8158, 8357, 8556, 8755, 8954, 9153,
        9352, 9551, 9750, 9949, 10148, 10347, 10546, 10745, 10944, 11143, 11342, 11541, 11740,
        11939, 12138, 12337, 12536, 12735, 12934, 13133, 13332, 13531, 13730, 13929, 14128, 14327,
        14526, 14725, 14924, 15123, 15322, 15521, 15720, 15919, 16118, 16317, 16516, 16715, 16914,
        17113, 17312, 17511, 17710, 17909, 18108, 18307, 18506, 18705, 18904, 19103, 19302, 19501,
        19700, 19899, 20098, 20297, 20496, 20695, 20894, 21093, 21292, 21491, 21690, 21889, 22088,
        22287, 22486, 22685, 22884, 23083, 23282, 23481, 23680, 23879, 24078, 24277, 24476, 24675,
        24874, 25073, 25272, 25471, 25670, 25869, 26068, 26267, 26466, 26665, 26864, 27063, 27262,
        27461, 27660, 27859, 28058, 28257, 28456, 28655, 28854, 29053, 29252, 29451, 29650, 29849,
        30048, 30247, 30446, 30645, 30844, 31043, 31242, 31441, 31640, 31839, 32038, 32237, 32436,
        32635, 32834, 33033, 33232, 33431, 33630, 33829, 34028, 34227, 34426, 34625, 34824, 35023,
        35222, 35421, 35620, 35819, 36018, 36217, 36416, 36615, 36814, 37013, 37212, 37411, 37610,
        37809, 38008, 38207, 38406, 38605, 38804, 39003, 39202, 39401, 39600, 39799, 39998, 40197,
        40396, 40595, 40794, 40993, 41192, 41391, 41590, 41789, 41988, 42187, 42386, 42585, 42784,
        42983, 43182, 43381, 43580, 43779, 43978, 44177, 44376, 44575, 44774, 44973, 45172, 45371,
        45570, 45769, 45968, 46167, 46366, 46565, 46764, 46963, 47162, 47361, 47560, 47759, 47958,
        48157, 48356, 48555, 48754, 48953, 49152, 49351, 49550, 49749, 49948, 50147, 50346, 50545,
        50744, 50943, 51142, 51341, 51540, 51739, 51938, 52137, 52336, 52535, 52734, 52933, 53132,
        53331, 53530, 53729, 53928, 54127, 54326, 54525, 54724, 54923, 55122, 55321, 55520, 55719,
        55918, 56117, 56316, 56515, 56714, 56913, 57112, 57311, 57510, 57709, 57908, 58107, 58306,
        58505, 58704, 58903, 59102, 59301, 59500, 59699, 59898, 60097, 60296, 60495, 60694, 60893,
        61092, 61291, 61490, 61689, 61888, 62087, 62286, 62485, 62684, 62883, 63082, 63281, 63480,
        63679, 63878, 64077, 64276, 64475, 64674, 64873, 65072, 65271, 65470, 65516, 65517, 65518,
        65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526, 65527, 65528, 65529, 65530, 65531,
        65532, 65533, 65534, 65535,
    ]);
    let results = Vec::from([
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    ]);
    for j in 0..offsets.len() {
        assert_result!(i, load8_u, offsets[j], results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_10() {
    let w = r#"
    (module
        (memory (export "mem") 1 1 )
        (data (i32.const 65515) "\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13\14")
        (func (export "run") (param $targetOffs i32) (param $srcOffs i32) (param $len i32)
            (memory.copy (local.get $targetOffs) (local.get $srcOffs) (local.get $len))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let run = get_func!(i, "run");
    let err = i.invoke::<(i32, i32, i32), ()>(run, (0, 65515, 39));
    if err.is_err() {
        assert!(err.unwrap_err() == RuntimeError::MemoryAccessOutOfBounds);
    }

    let load8_u = get_func!(i, "load8_u");
    let offsets = Vec::from([
        198, 397, 596, 795, 994, 1193, 1392, 1591, 1790, 1989, 2188, 2387, 2586, 2785, 2984, 3183,
        3382, 3581, 3780, 3979, 4178, 4377, 4576, 4775, 4974, 5173, 5372, 5571, 5770, 5969, 6168,
        6367, 6566, 6765, 6964, 7163, 7362, 7561, 7760, 7959, 8158, 8357, 8556, 8755, 8954, 9153,
        9352, 9551, 9750, 9949, 10148, 10347, 10546, 10745, 10944, 11143, 11342, 11541, 11740,
        11939, 12138, 12337, 12536, 12735, 12934, 13133, 13332, 13531, 13730, 13929, 14128, 14327,
        14526, 14725, 14924, 15123, 15322, 15521, 15720, 15919, 16118, 16317, 16516, 16715, 16914,
        17113, 17312, 17511, 17710, 17909, 18108, 18307, 18506, 18705, 18904, 19103, 19302, 19501,
        19700, 19899, 20098, 20297, 20496, 20695, 20894, 21093, 21292, 21491, 21690, 21889, 22088,
        22287, 22486, 22685, 22884, 23083, 23282, 23481, 23680, 23879, 24078, 24277, 24476, 24675,
        24874, 25073, 25272, 25471, 25670, 25869, 26068, 26267, 26466, 26665, 26864, 27063, 27262,
        27461, 27660, 27859, 28058, 28257, 28456, 28655, 28854, 29053, 29252, 29451, 29650, 29849,
        30048, 30247, 30446, 30645, 30844, 31043, 31242, 31441, 31640, 31839, 32038, 32237, 32436,
        32635, 32834, 33033, 33232, 33431, 33630, 33829, 34028, 34227, 34426, 34625, 34824, 35023,
        35222, 35421, 35620, 35819, 36018, 36217, 36416, 36615, 36814, 37013, 37212, 37411, 37610,
        37809, 38008, 38207, 38406, 38605, 38804, 39003, 39202, 39401, 39600, 39799, 39998, 40197,
        40396, 40595, 40794, 40993, 41192, 41391, 41590, 41789, 41988, 42187, 42386, 42585, 42784,
        42983, 43182, 43381, 43580, 43779, 43978, 44177, 44376, 44575, 44774, 44973, 45172, 45371,
        45570, 45769, 45968, 46167, 46366, 46565, 46764, 46963, 47162, 47361, 47560, 47759, 47958,
        48157, 48356, 48555, 48754, 48953, 49152, 49351, 49550, 49749, 49948, 50147, 50346, 50545,
        50744, 50943, 51142, 51341, 51540, 51739, 51938, 52137, 52336, 52535, 52734, 52933, 53132,
        53331, 53530, 53729, 53928, 54127, 54326, 54525, 54724, 54923, 55122, 55321, 55520, 55719,
        55918, 56117, 56316, 56515, 56714, 56913, 57112, 57311, 57510, 57709, 57908, 58107, 58306,
        58505, 58704, 58903, 59102, 59301, 59500, 59699, 59898, 60097, 60296, 60495, 60694, 60893,
        61092, 61291, 61490, 61689, 61888, 62087, 62286, 62485, 62684, 62883, 63082, 63281, 63480,
        63679, 63878, 64077, 64276, 64475, 64674, 64873, 65072, 65271, 65470, 65515, 65516, 65517,
        65518, 65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526, 65527, 65528, 65529, 65530,
        65531, 65532, 65533, 65534, 65535,
    ]);
    let results = Vec::from([
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20,
    ]);
    for j in 0..offsets.len() {
        assert_result!(i, load8_u, offsets[j], results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_11() {
    let w = r#"
    (module
        (memory (export "mem") 1 1 )
        (data (i32.const 65486) "\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13")
        (func (export "run") (param $targetOffs i32) (param $srcOffs i32) (param $len i32)
            (memory.copy (local.get $targetOffs) (local.get $srcOffs) (local.get $len))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let run = get_func!(i, "run");
    let err = i.invoke::<(i32, i32, i32), ()>(run, (65516, 65486, 40));
    if err.is_err() {
        assert!(err.unwrap_err() == RuntimeError::MemoryAccessOutOfBounds);
    }

    let load8_u = get_func!(i, "load8_u");
    let offsets = Vec::from([
        198, 397, 596, 795, 994, 1193, 1392, 1591, 1790, 1989, 2188, 2387, 2586, 2785, 2984, 3183,
        3382, 3581, 3780, 3979, 4178, 4377, 4576, 4775, 4974, 5173, 5372, 5571, 5770, 5969, 6168,
        6367, 6566, 6765, 6964, 7163, 7362, 7561, 7760, 7959, 8158, 8357, 8556, 8755, 8954, 9153,
        9352, 9551, 9750, 9949, 10148, 10347, 10546, 10745, 10944, 11143, 11342, 11541, 11740,
        11939, 12138, 12337, 12536, 12735, 12934, 13133, 13332, 13531, 13730, 13929, 14128, 14327,
        14526, 14725, 14924, 15123, 15322, 15521, 15720, 15919, 16118, 16317, 16516, 16715, 16914,
        17113, 17312, 17511, 17710, 17909, 18108, 18307, 18506, 18705, 18904, 19103, 19302, 19501,
        19700, 19899, 20098, 20297, 20496, 20695, 20894, 21093, 21292, 21491, 21690, 21889, 22088,
        22287, 22486, 22685, 22884, 23083, 23282, 23481, 23680, 23879, 24078, 24277, 24476, 24675,
        24874, 25073, 25272, 25471, 25670, 25869, 26068, 26267, 26466, 26665, 26864, 27063, 27262,
        27461, 27660, 27859, 28058, 28257, 28456, 28655, 28854, 29053, 29252, 29451, 29650, 29849,
        30048, 30247, 30446, 30645, 30844, 31043, 31242, 31441, 31640, 31839, 32038, 32237, 32436,
        32635, 32834, 33033, 33232, 33431, 33630, 33829, 34028, 34227, 34426, 34625, 34824, 35023,
        35222, 35421, 35620, 35819, 36018, 36217, 36416, 36615, 36814, 37013, 37212, 37411, 37610,
        37809, 38008, 38207, 38406, 38605, 38804, 39003, 39202, 39401, 39600, 39799, 39998, 40197,
        40396, 40595, 40794, 40993, 41192, 41391, 41590, 41789, 41988, 42187, 42386, 42585, 42784,
        42983, 43182, 43381, 43580, 43779, 43978, 44177, 44376, 44575, 44774, 44973, 45172, 45371,
        45570, 45769, 45968, 46167, 46366, 46565, 46764, 46963, 47162, 47361, 47560, 47759, 47958,
        48157, 48356, 48555, 48754, 48953, 49152, 49351, 49550, 49749, 49948, 50147, 50346, 50545,
        50744, 50943, 51142, 51341, 51540, 51739, 51938, 52137, 52336, 52535, 52734, 52933, 53132,
        53331, 53530, 53729, 53928, 54127, 54326, 54525, 54724, 54923, 55122, 55321, 55520, 55719,
        55918, 56117, 56316, 56515, 56714, 56913, 57112, 57311, 57510, 57709, 57908, 58107, 58306,
        58505, 58704, 58903, 59102, 59301, 59500, 59699, 59898, 60097, 60296, 60495, 60694, 60893,
        61092, 61291, 61490, 61689, 61888, 62087, 62286, 62485, 62684, 62883, 63082, 63281, 63480,
        63679, 63878, 64077, 64276, 64475, 64674, 64873, 65072, 65271, 65470, 65486, 65487, 65488,
        65489, 65490, 65491, 65492, 65493, 65494, 65495, 65496, 65497, 65498, 65499, 65500, 65501,
        65502, 65503, 65504, 65505,
    ]);
    let results = Vec::from([
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    ]);
    for j in 0..offsets.len() {
        assert_result!(i, load8_u, offsets[j], results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_12() {
    let w = r#"
    (module
        (memory (export "mem") 1 1 )
        (data (i32.const 65516) "\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13")
        (func (export "run") (param $targetOffs i32) (param $srcOffs i32) (param $len i32)
            (memory.copy (local.get $targetOffs) (local.get $srcOffs) (local.get $len))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let run = get_func!(i, "run");
    let err = i.invoke::<(i32, i32, i32), ()>(run, (65486, 65516, 40));
    if err.is_err() {
        assert!(err.unwrap_err() == RuntimeError::MemoryAccessOutOfBounds);
    }

    let load8_u = get_func!(i, "load8_u");
    let offsets = Vec::from([
        198, 397, 596, 795, 994, 1193, 1392, 1591, 1790, 1989, 2188, 2387, 2586, 2785, 2984, 3183,
        3382, 3581, 3780, 3979, 4178, 4377, 4576, 4775, 4974, 5173, 5372, 5571, 5770, 5969, 6168,
        6367, 6566, 6765, 6964, 7163, 7362, 7561, 7760, 7959, 8158, 8357, 8556, 8755, 8954, 9153,
        9352, 9551, 9750, 9949, 10148, 10347, 10546, 10745, 10944, 11143, 11342, 11541, 11740,
        11939, 12138, 12337, 12536, 12735, 12934, 13133, 13332, 13531, 13730, 13929, 14128, 14327,
        14526, 14725, 14924, 15123, 15322, 15521, 15720, 15919, 16118, 16317, 16516, 16715, 16914,
        17113, 17312, 17511, 17710, 17909, 18108, 18307, 18506, 18705, 18904, 19103, 19302, 19501,
        19700, 19899, 20098, 20297, 20496, 20695, 20894, 21093, 21292, 21491, 21690, 21889, 22088,
        22287, 22486, 22685, 22884, 23083, 23282, 23481, 23680, 23879, 24078, 24277, 24476, 24675,
        24874, 25073, 25272, 25471, 25670, 25869, 26068, 26267, 26466, 26665, 26864, 27063, 27262,
        27461, 27660, 27859, 28058, 28257, 28456, 28655, 28854, 29053, 29252, 29451, 29650, 29849,
        30048, 30247, 30446, 30645, 30844, 31043, 31242, 31441, 31640, 31839, 32038, 32237, 32436,
        32635, 32834, 33033, 33232, 33431, 33630, 33829, 34028, 34227, 34426, 34625, 34824, 35023,
        35222, 35421, 35620, 35819, 36018, 36217, 36416, 36615, 36814, 37013, 37212, 37411, 37610,
        37809, 38008, 38207, 38406, 38605, 38804, 39003, 39202, 39401, 39600, 39799, 39998, 40197,
        40396, 40595, 40794, 40993, 41192, 41391, 41590, 41789, 41988, 42187, 42386, 42585, 42784,
        42983, 43182, 43381, 43580, 43779, 43978, 44177, 44376, 44575, 44774, 44973, 45172, 45371,
        45570, 45769, 45968, 46167, 46366, 46565, 46764, 46963, 47162, 47361, 47560, 47759, 47958,
        48157, 48356, 48555, 48754, 48953, 49152, 49351, 49550, 49749, 49948, 50147, 50346, 50545,
        50744, 50943, 51142, 51341, 51540, 51739, 51938, 52137, 52336, 52535, 52734, 52933, 53132,
        53331, 53530, 53729, 53928, 54127, 54326, 54525, 54724, 54923, 55122, 55321, 55520, 55719,
        55918, 56117, 56316, 56515, 56714, 56913, 57112, 57311, 57510, 57709, 57908, 58107, 58306,
        58505, 58704, 58903, 59102, 59301, 59500, 59699, 59898, 60097, 60296, 60495, 60694, 60893,
        61092, 61291, 61490, 61689, 61888, 62087, 62286, 62485, 62684, 62883, 63082, 63281, 63480,
        63679, 63878, 64077, 64276, 64475, 64674, 64873, 65072, 65271, 65470, 65516, 65517, 65518,
        65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526, 65527, 65528, 65529, 65530, 65531,
        65532, 65533, 65534, 65535,
    ]);
    let results = Vec::from([
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    ]);
    for j in 0..offsets.len() {
        assert_result!(i, load8_u, offsets[j], results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_13() {
    let w = r#"
    (module
        (memory (export "mem") 1 1 )
        (data (i32.const 65506) "\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13")
        (func (export "run") (param $targetOffs i32) (param $srcOffs i32) (param $len i32)
            (memory.copy (local.get $targetOffs) (local.get $srcOffs) (local.get $len))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let run = get_func!(i, "run");
    let err = i.invoke::<(i32, i32, i32), ()>(run, (65516, 65506, 40));
    if err.is_err() {
        assert!(err.unwrap_err() == RuntimeError::MemoryAccessOutOfBounds);
    }

    let load8_u = get_func!(i, "load8_u");
    let offsets = Vec::from([
        198, 397, 596, 795, 994, 1193, 1392, 1591, 1790, 1989, 2188, 2387, 2586, 2785, 2984, 3183,
        3382, 3581, 3780, 3979, 4178, 4377, 4576, 4775, 4974, 5173, 5372, 5571, 5770, 5969, 6168,
        6367, 6566, 6765, 6964, 7163, 7362, 7561, 7760, 7959, 8158, 8357, 8556, 8755, 8954, 9153,
        9352, 9551, 9750, 9949, 10148, 10347, 10546, 10745, 10944, 11143, 11342, 11541, 11740,
        11939, 12138, 12337, 12536, 12735, 12934, 13133, 13332, 13531, 13730, 13929, 14128, 14327,
        14526, 14725, 14924, 15123, 15322, 15521, 15720, 15919, 16118, 16317, 16516, 16715, 16914,
        17113, 17312, 17511, 17710, 17909, 18108, 18307, 18506, 18705, 18904, 19103, 19302, 19501,
        19700, 19899, 20098, 20297, 20496, 20695, 20894, 21093, 21292, 21491, 21690, 21889, 22088,
        22287, 22486, 22685, 22884, 23083, 23282, 23481, 23680, 23879, 24078, 24277, 24476, 24675,
        24874, 25073, 25272, 25471, 25670, 25869, 26068, 26267, 26466, 26665, 26864, 27063, 27262,
        27461, 27660, 27859, 28058, 28257, 28456, 28655, 28854, 29053, 29252, 29451, 29650, 29849,
        30048, 30247, 30446, 30645, 30844, 31043, 31242, 31441, 31640, 31839, 32038, 32237, 32436,
        32635, 32834, 33033, 33232, 33431, 33630, 33829, 34028, 34227, 34426, 34625, 34824, 35023,
        35222, 35421, 35620, 35819, 36018, 36217, 36416, 36615, 36814, 37013, 37212, 37411, 37610,
        37809, 38008, 38207, 38406, 38605, 38804, 39003, 39202, 39401, 39600, 39799, 39998, 40197,
        40396, 40595, 40794, 40993, 41192, 41391, 41590, 41789, 41988, 42187, 42386, 42585, 42784,
        42983, 43182, 43381, 43580, 43779, 43978, 44177, 44376, 44575, 44774, 44973, 45172, 45371,
        45570, 45769, 45968, 46167, 46366, 46565, 46764, 46963, 47162, 47361, 47560, 47759, 47958,
        48157, 48356, 48555, 48754, 48953, 49152, 49351, 49550, 49749, 49948, 50147, 50346, 50545,
        50744, 50943, 51142, 51341, 51540, 51739, 51938, 52137, 52336, 52535, 52734, 52933, 53132,
        53331, 53530, 53729, 53928, 54127, 54326, 54525, 54724, 54923, 55122, 55321, 55520, 55719,
        55918, 56117, 56316, 56515, 56714, 56913, 57112, 57311, 57510, 57709, 57908, 58107, 58306,
        58505, 58704, 58903, 59102, 59301, 59500, 59699, 59898, 60097, 60296, 60495, 60694, 60893,
        61092, 61291, 61490, 61689, 61888, 62087, 62286, 62485, 62684, 62883, 63082, 63281, 63480,
        63679, 63878, 64077, 64276, 64475, 64674, 64873, 65072, 65271, 65470, 65506, 65507, 65508,
        65509, 65510, 65511, 65512, 65513, 65514, 65515, 65516, 65517, 65518, 65519, 65520, 65521,
        65522, 65523, 65524, 65525,
    ]);
    let results = Vec::from([
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    ]);
    for j in 0..offsets.len() {
        assert_result!(i, load8_u, offsets[j], results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_14() {
    let w = r#"
    (module
        (memory (export "mem") 1 1 )
        (data (i32.const 65516) "\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13")
        (func (export "run") (param $targetOffs i32) (param $srcOffs i32) (param $len i32)
            (memory.copy (local.get $targetOffs) (local.get $srcOffs) (local.get $len))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let run = get_func!(i, "run");
    let err = i.invoke::<(i32, i32, i32), ()>(run, (65506, 65516, 40));
    if err.is_err() {
        assert!(err.unwrap_err() == RuntimeError::MemoryAccessOutOfBounds);
    }

    let load8_u = get_func!(i, "load8_u");
    let offsets = Vec::from([
        198, 397, 596, 795, 994, 1193, 1392, 1591, 1790, 1989, 2188, 2387, 2586, 2785, 2984, 3183,
        3382, 3581, 3780, 3979, 4178, 4377, 4576, 4775, 4974, 5173, 5372, 5571, 5770, 5969, 6168,
        6367, 6566, 6765, 6964, 7163, 7362, 7561, 7760, 7959, 8158, 8357, 8556, 8755, 8954, 9153,
        9352, 9551, 9750, 9949, 10148, 10347, 10546, 10745, 10944, 11143, 11342, 11541, 11740,
        11939, 12138, 12337, 12536, 12735, 12934, 13133, 13332, 13531, 13730, 13929, 14128, 14327,
        14526, 14725, 14924, 15123, 15322, 15521, 15720, 15919, 16118, 16317, 16516, 16715, 16914,
        17113, 17312, 17511, 17710, 17909, 18108, 18307, 18506, 18705, 18904, 19103, 19302, 19501,
        19700, 19899, 20098, 20297, 20496, 20695, 20894, 21093, 21292, 21491, 21690, 21889, 22088,
        22287, 22486, 22685, 22884, 23083, 23282, 23481, 23680, 23879, 24078, 24277, 24476, 24675,
        24874, 25073, 25272, 25471, 25670, 25869, 26068, 26267, 26466, 26665, 26864, 27063, 27262,
        27461, 27660, 27859, 28058, 28257, 28456, 28655, 28854, 29053, 29252, 29451, 29650, 29849,
        30048, 30247, 30446, 30645, 30844, 31043, 31242, 31441, 31640, 31839, 32038, 32237, 32436,
        32635, 32834, 33033, 33232, 33431, 33630, 33829, 34028, 34227, 34426, 34625, 34824, 35023,
        35222, 35421, 35620, 35819, 36018, 36217, 36416, 36615, 36814, 37013, 37212, 37411, 37610,
        37809, 38008, 38207, 38406, 38605, 38804, 39003, 39202, 39401, 39600, 39799, 39998, 40197,
        40396, 40595, 40794, 40993, 41192, 41391, 41590, 41789, 41988, 42187, 42386, 42585, 42784,
        42983, 43182, 43381, 43580, 43779, 43978, 44177, 44376, 44575, 44774, 44973, 45172, 45371,
        45570, 45769, 45968, 46167, 46366, 46565, 46764, 46963, 47162, 47361, 47560, 47759, 47958,
        48157, 48356, 48555, 48754, 48953, 49152, 49351, 49550, 49749, 49948, 50147, 50346, 50545,
        50744, 50943, 51142, 51341, 51540, 51739, 51938, 52137, 52336, 52535, 52734, 52933, 53132,
        53331, 53530, 53729, 53928, 54127, 54326, 54525, 54724, 54923, 55122, 55321, 55520, 55719,
        55918, 56117, 56316, 56515, 56714, 56913, 57112, 57311, 57510, 57709, 57908, 58107, 58306,
        58505, 58704, 58903, 59102, 59301, 59500, 59699, 59898, 60097, 60296, 60495, 60694, 60893,
        61092, 61291, 61490, 61689, 61888, 62087, 62286, 62485, 62684, 62883, 63082, 63281, 63480,
        63679, 63878, 64077, 64276, 64475, 64674, 64873, 65072, 65271, 65470, 65516, 65517, 65518,
        65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526, 65527, 65528, 65529, 65530, 65531,
        65532, 65533, 65534, 65535,
    ]);
    let results = Vec::from([
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    ]);
    for j in 0..offsets.len() {
        assert_result!(i, load8_u, offsets[j], results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_15() {
    let w = r#"
    (module
        (memory (export "mem") 1 1 )
        (data (i32.const 65516) "\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13")
        (func (export "run") (param $targetOffs i32) (param $srcOffs i32) (param $len i32)
            (memory.copy (local.get $targetOffs) (local.get $srcOffs) (local.get $len))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let run = get_func!(i, "run");
    let err = i.invoke::<(i32, i32, i32), ()>(run, (65516, 65516, 40));
    if err.is_err() {
        assert!(err.unwrap_err() == RuntimeError::MemoryAccessOutOfBounds);
    }

    let load8_u = get_func!(i, "load8_u");
    let offsets = Vec::from([
        198, 397, 596, 795, 994, 1193, 1392, 1591, 1790, 1989, 2188, 2387, 2586, 2785, 2984, 3183,
        3382, 3581, 3780, 3979, 4178, 4377, 4576, 4775, 4974, 5173, 5372, 5571, 5770, 5969, 6168,
        6367, 6566, 6765, 6964, 7163, 7362, 7561, 7760, 7959, 8158, 8357, 8556, 8755, 8954, 9153,
        9352, 9551, 9750, 9949, 10148, 10347, 10546, 10745, 10944, 11143, 11342, 11541, 11740,
        11939, 12138, 12337, 12536, 12735, 12934, 13133, 13332, 13531, 13730, 13929, 14128, 14327,
        14526, 14725, 14924, 15123, 15322, 15521, 15720, 15919, 16118, 16317, 16516, 16715, 16914,
        17113, 17312, 17511, 17710, 17909, 18108, 18307, 18506, 18705, 18904, 19103, 19302, 19501,
        19700, 19899, 20098, 20297, 20496, 20695, 20894, 21093, 21292, 21491, 21690, 21889, 22088,
        22287, 22486, 22685, 22884, 23083, 23282, 23481, 23680, 23879, 24078, 24277, 24476, 24675,
        24874, 25073, 25272, 25471, 25670, 25869, 26068, 26267, 26466, 26665, 26864, 27063, 27262,
        27461, 27660, 27859, 28058, 28257, 28456, 28655, 28854, 29053, 29252, 29451, 29650, 29849,
        30048, 30247, 30446, 30645, 30844, 31043, 31242, 31441, 31640, 31839, 32038, 32237, 32436,
        32635, 32834, 33033, 33232, 33431, 33630, 33829, 34028, 34227, 34426, 34625, 34824, 35023,
        35222, 35421, 35620, 35819, 36018, 36217, 36416, 36615, 36814, 37013, 37212, 37411, 37610,
        37809, 38008, 38207, 38406, 38605, 38804, 39003, 39202, 39401, 39600, 39799, 39998, 40197,
        40396, 40595, 40794, 40993, 41192, 41391, 41590, 41789, 41988, 42187, 42386, 42585, 42784,
        42983, 43182, 43381, 43580, 43779, 43978, 44177, 44376, 44575, 44774, 44973, 45172, 45371,
        45570, 45769, 45968, 46167, 46366, 46565, 46764, 46963, 47162, 47361, 47560, 47759, 47958,
        48157, 48356, 48555, 48754, 48953, 49152, 49351, 49550, 49749, 49948, 50147, 50346, 50545,
        50744, 50943, 51142, 51341, 51540, 51739, 51938, 52137, 52336, 52535, 52734, 52933, 53132,
        53331, 53530, 53729, 53928, 54127, 54326, 54525, 54724, 54923, 55122, 55321, 55520, 55719,
        55918, 56117, 56316, 56515, 56714, 56913, 57112, 57311, 57510, 57709, 57908, 58107, 58306,
        58505, 58704, 58903, 59102, 59301, 59500, 59699, 59898, 60097, 60296, 60495, 60694, 60893,
        61092, 61291, 61490, 61689, 61888, 62087, 62286, 62485, 62684, 62883, 63082, 63281, 63480,
        63679, 63878, 64077, 64276, 64475, 64674, 64873, 65072, 65271, 65470, 65516, 65517, 65518,
        65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526, 65527, 65528, 65529, 65530, 65531,
        65532, 65533, 65534, 65535,
    ]);
    let results = Vec::from([
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    ]);
    for j in 0..offsets.len() {
        assert_result!(i, load8_u, offsets[j], results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_16() {
    let w = r#"
    (module
        (memory (export "mem") 1 1 )
        (data (i32.const 65516) "\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13")
        (func (export "run") (param $targetOffs i32) (param $srcOffs i32) (param $len i32)
            (memory.copy (local.get $targetOffs) (local.get $srcOffs) (local.get $len))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let run = get_func!(i, "run");
    let err = i.invoke::<(i32, i32, i32), ()>(run, (0, 65516, 4294963200_u32 as i32));
    if err.is_err() {
        assert!(err.unwrap_err() == RuntimeError::MemoryAccessOutOfBounds);
    }

    let load8_u = get_func!(i, "load8_u");
    let offsets = Vec::from([
        198, 397, 596, 795, 994, 1193, 1392, 1591, 1790, 1989, 2188, 2387, 2586, 2785, 2984, 3183,
        3382, 3581, 3780, 3979, 4178, 4377, 4576, 4775, 4974, 5173, 5372, 5571, 5770, 5969, 6168,
        6367, 6566, 6765, 6964, 7163, 7362, 7561, 7760, 7959, 8158, 8357, 8556, 8755, 8954, 9153,
        9352, 9551, 9750, 9949, 10148, 10347, 10546, 10745, 10944, 11143, 11342, 11541, 11740,
        11939, 12138, 12337, 12536, 12735, 12934, 13133, 13332, 13531, 13730, 13929, 14128, 14327,
        14526, 14725, 14924, 15123, 15322, 15521, 15720, 15919, 16118, 16317, 16516, 16715, 16914,
        17113, 17312, 17511, 17710, 17909, 18108, 18307, 18506, 18705, 18904, 19103, 19302, 19501,
        19700, 19899, 20098, 20297, 20496, 20695, 20894, 21093, 21292, 21491, 21690, 21889, 22088,
        22287, 22486, 22685, 22884, 23083, 23282, 23481, 23680, 23879, 24078, 24277, 24476, 24675,
        24874, 25073, 25272, 25471, 25670, 25869, 26068, 26267, 26466, 26665, 26864, 27063, 27262,
        27461, 27660, 27859, 28058, 28257, 28456, 28655, 28854, 29053, 29252, 29451, 29650, 29849,
        30048, 30247, 30446, 30645, 30844, 31043, 31242, 31441, 31640, 31839, 32038, 32237, 32436,
        32635, 32834, 33033, 33232, 33431, 33630, 33829, 34028, 34227, 34426, 34625, 34824, 35023,
        35222, 35421, 35620, 35819, 36018, 36217, 36416, 36615, 36814, 37013, 37212, 37411, 37610,
        37809, 38008, 38207, 38406, 38605, 38804, 39003, 39202, 39401, 39600, 39799, 39998, 40197,
        40396, 40595, 40794, 40993, 41192, 41391, 41590, 41789, 41988, 42187, 42386, 42585, 42784,
        42983, 43182, 43381, 43580, 43779, 43978, 44177, 44376, 44575, 44774, 44973, 45172, 45371,
        45570, 45769, 45968, 46167, 46366, 46565, 46764, 46963, 47162, 47361, 47560, 47759, 47958,
        48157, 48356, 48555, 48754, 48953, 49152, 49351, 49550, 49749, 49948, 50147, 50346, 50545,
        50744, 50943, 51142, 51341, 51540, 51739, 51938, 52137, 52336, 52535, 52734, 52933, 53132,
        53331, 53530, 53729, 53928, 54127, 54326, 54525, 54724, 54923, 55122, 55321, 55520, 55719,
        55918, 56117, 56316, 56515, 56714, 56913, 57112, 57311, 57510, 57709, 57908, 58107, 58306,
        58505, 58704, 58903, 59102, 59301, 59500, 59699, 59898, 60097, 60296, 60495, 60694, 60893,
        61092, 61291, 61490, 61689, 61888, 62087, 62286, 62485, 62684, 62883, 63082, 63281, 63480,
        63679, 63878, 64077, 64276, 64475, 64674, 64873, 65072, 65271, 65470, 65516, 65517, 65518,
        65519, 65520, 65521, 65522, 65523, 65524, 65525, 65526, 65527, 65528, 65529, 65530, 65531,
        65532, 65533, 65534, 65535,
    ]);
    let results = Vec::from([
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,
    ]);
    for j in 0..offsets.len() {
        assert_result!(i, load8_u, offsets[j], results[j]);
    }
}

#[test_log::test]
fn memory_copy_test_17() {
    let w = r#"
    (module
        (memory (export "mem") 1 1 )
        (data (i32.const 61440) "\00\01\02\03\04\05\06\07\08\09\0a\0b\0c\0d\0e\0f\10\11\12\13")
        (func (export "run") (param $targetOffs i32) (param $srcOffs i32) (param $len i32)
            (memory.copy (local.get $targetOffs) (local.get $srcOffs) (local.get $len))
        )
        (func (export "load8_u") (param i32) (result i32)
            (i32.load8_u (local.get 0))
        )
    )
  "#;
    let wasm_bytes = wat::parse_str(w).unwrap();
    let validation_info = validate(&wasm_bytes).unwrap();
    let mut i = RuntimeInstance::new(&validation_info).expect("instantiation failed");

    let run = get_func!(i, "run");
    let err = i.invoke::<(i32, i32, i32), ()>(run, (65516, 61440, 4294967040_u32 as i32));
    if err.is_err() {
        assert!(err.unwrap_err() == RuntimeError::MemoryAccessOutOfBounds);
    }

    let load8_u = get_func!(i, "load8_u");
    let offsets = Vec::from([
        198, 397, 596, 795, 994, 1193, 1392, 1591, 1790, 1989, 2188, 2387, 2586, 2785, 2984, 3183,
        3382, 3581, 3780, 3979, 4178, 4377, 4576, 4775, 4974, 5173, 5372, 5571, 5770, 5969, 6168,
        6367, 6566, 6765, 6964, 7163, 7362, 7561, 7760, 7959, 8158, 8357, 8556, 8755, 8954, 9153,
        9352, 9551, 9750, 9949, 10148, 10347, 10546, 10745, 10944, 11143, 11342, 11541, 11740,
        11939, 12138, 12337, 12536, 12735, 12934, 13133, 13332, 13531, 13730, 13929, 14128, 14327,
        14526, 14725, 14924, 15123, 15322, 15521, 15720, 15919, 16118, 16317, 16516, 16715, 16914,
        17113, 17312, 17511, 17710, 17909, 18108, 18307, 18506, 18705, 18904, 19103, 19302, 19501,
        19700, 19899, 20098, 20297, 20496, 20695, 20894, 21093, 21292, 21491, 21690, 21889, 22088,
        22287, 22486, 22685, 22884, 23083, 23282, 23481, 23680, 23879, 24078, 24277, 24476, 24675,
        24874, 25073, 25272, 25471, 25670, 25869, 26068, 26267, 26466, 26665, 26864, 27063, 27262,
        27461, 27660, 27859, 28058, 28257, 28456, 28655, 28854, 29053, 29252, 29451, 29650, 29849,
        30048, 30247, 30446, 30645, 30844, 31043, 31242, 31441, 31640, 31839, 32038, 32237, 32436,
        32635, 32834, 33033, 33232, 33431, 33630, 33829, 34028, 34227, 34426, 34625, 34824, 35023,
        35222, 35421, 35620, 35819, 36018, 36217, 36416, 36615, 36814, 37013, 37212, 37411, 37610,
        37809, 38008, 38207, 38406, 38605, 38804, 39003, 39202, 39401, 39600, 39799, 39998, 40197,
        40396, 40595, 40794, 40993, 41192, 41391, 41590, 41789, 41988, 42187, 42386, 42585, 42784,
        42983, 43182, 43381, 43580, 43779, 43978, 44177, 44376, 44575, 44774, 44973, 45172, 45371,
        45570, 45769, 45968, 46167, 46366, 46565, 46764, 46963, 47162, 47361, 47560, 47759, 47958,
        48157, 48356, 48555, 48754, 48953, 49152, 49351, 49550, 49749, 49948, 50147, 50346, 50545,
        50744, 50943, 51142, 51341, 51540, 51739, 51938, 52137, 52336, 52535, 52734, 52933, 53132,
        53331, 53530, 53729, 53928, 54127, 54326, 54525, 54724, 54923, 55122, 55321, 55520, 55719,
        55918, 56117, 56316, 56515, 56714, 56913, 57112, 57311, 57510, 57709, 57908, 58107, 58306,
        58505, 58704, 58903, 59102, 59301, 59500, 59699, 59898, 60097, 60296, 60495, 60694, 60893,
        61092, 61291, 61440, 61441, 61442, 61443, 61444, 61445, 61446, 61447, 61448, 61449, 61450,
        61451, 61452, 61453, 61454, 61455, 61456, 61457, 61458, 61459, 61510, 61709, 61908, 62107,
        62306, 62505, 62704, 62903, 63102, 63301, 63500, 63699, 63898, 64097, 64296, 64495, 64694,
        64893, 65092, 65291, 65490,
    ]);
    let results = Vec::from([
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18,
        19, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ]);
    for j in 0..offsets.len() {
        assert_result!(i, load8_u, offsets[j], results[j]);
    }
}
