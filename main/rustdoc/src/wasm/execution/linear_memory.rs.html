<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `src/execution/linear_memory.rs`."><title>linear_memory.rs - source</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../../static.files/rustdoc-492a78a4a87dcc01.css"><meta name="rustdoc-vars" data-root-path="../../../" data-static-root-path="../../../static.files/" data-current-crate="wasm" data-themes="" data-resource-suffix="" data-rustdoc-version="1.82.0 (f6e511eec 2024-10-15) (built from a source tarball)" data-channel="1.82.0" data-search-js="search-a99f1315e7cc5121.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../../../static.files/src-script-e66d777a5a92e9b2.js"></script><script defer src="../../../src-files.js"></script><script defer src="../../../static.files/main-921df33f47b8780c.js"></script><noscript><link rel="stylesheet" href="../../../static.files/noscript-3b12f09e550e0385.css"></noscript><link rel="alternate icon" type="image/png" href="../../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc src"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="src-sidebar-title"><h2>Files</h2></div></nav><div class="sidebar-resizer"></div><main><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="example-wrap"><div data-nosnippet><pre class="src-line-numbers"><a href="#1" id="1">1</a>
<a href="#2" id="2">2</a>
<a href="#3" id="3">3</a>
<a href="#4" id="4">4</a>
<a href="#5" id="5">5</a>
<a href="#6" id="6">6</a>
<a href="#7" id="7">7</a>
<a href="#8" id="8">8</a>
<a href="#9" id="9">9</a>
<a href="#10" id="10">10</a>
<a href="#11" id="11">11</a>
<a href="#12" id="12">12</a>
<a href="#13" id="13">13</a>
<a href="#14" id="14">14</a>
<a href="#15" id="15">15</a>
<a href="#16" id="16">16</a>
<a href="#17" id="17">17</a>
<a href="#18" id="18">18</a>
<a href="#19" id="19">19</a>
<a href="#20" id="20">20</a>
<a href="#21" id="21">21</a>
<a href="#22" id="22">22</a>
<a href="#23" id="23">23</a>
<a href="#24" id="24">24</a>
<a href="#25" id="25">25</a>
<a href="#26" id="26">26</a>
<a href="#27" id="27">27</a>
<a href="#28" id="28">28</a>
<a href="#29" id="29">29</a>
<a href="#30" id="30">30</a>
<a href="#31" id="31">31</a>
<a href="#32" id="32">32</a>
<a href="#33" id="33">33</a>
<a href="#34" id="34">34</a>
<a href="#35" id="35">35</a>
<a href="#36" id="36">36</a>
<a href="#37" id="37">37</a>
<a href="#38" id="38">38</a>
<a href="#39" id="39">39</a>
<a href="#40" id="40">40</a>
<a href="#41" id="41">41</a>
<a href="#42" id="42">42</a>
<a href="#43" id="43">43</a>
<a href="#44" id="44">44</a>
<a href="#45" id="45">45</a>
<a href="#46" id="46">46</a>
<a href="#47" id="47">47</a>
<a href="#48" id="48">48</a>
<a href="#49" id="49">49</a>
<a href="#50" id="50">50</a>
<a href="#51" id="51">51</a>
<a href="#52" id="52">52</a>
<a href="#53" id="53">53</a>
<a href="#54" id="54">54</a>
<a href="#55" id="55">55</a>
<a href="#56" id="56">56</a>
<a href="#57" id="57">57</a>
<a href="#58" id="58">58</a>
<a href="#59" id="59">59</a>
<a href="#60" id="60">60</a>
<a href="#61" id="61">61</a>
<a href="#62" id="62">62</a>
<a href="#63" id="63">63</a>
<a href="#64" id="64">64</a>
<a href="#65" id="65">65</a>
<a href="#66" id="66">66</a>
<a href="#67" id="67">67</a>
<a href="#68" id="68">68</a>
<a href="#69" id="69">69</a>
<a href="#70" id="70">70</a>
<a href="#71" id="71">71</a>
<a href="#72" id="72">72</a>
<a href="#73" id="73">73</a>
<a href="#74" id="74">74</a>
<a href="#75" id="75">75</a>
<a href="#76" id="76">76</a>
<a href="#77" id="77">77</a>
<a href="#78" id="78">78</a>
<a href="#79" id="79">79</a>
<a href="#80" id="80">80</a>
<a href="#81" id="81">81</a>
<a href="#82" id="82">82</a>
<a href="#83" id="83">83</a>
<a href="#84" id="84">84</a>
<a href="#85" id="85">85</a>
<a href="#86" id="86">86</a>
<a href="#87" id="87">87</a>
<a href="#88" id="88">88</a>
<a href="#89" id="89">89</a>
<a href="#90" id="90">90</a>
<a href="#91" id="91">91</a>
<a href="#92" id="92">92</a>
<a href="#93" id="93">93</a>
<a href="#94" id="94">94</a>
<a href="#95" id="95">95</a>
<a href="#96" id="96">96</a>
<a href="#97" id="97">97</a>
<a href="#98" id="98">98</a>
<a href="#99" id="99">99</a>
<a href="#100" id="100">100</a>
<a href="#101" id="101">101</a>
<a href="#102" id="102">102</a>
<a href="#103" id="103">103</a>
<a href="#104" id="104">104</a>
<a href="#105" id="105">105</a>
<a href="#106" id="106">106</a>
<a href="#107" id="107">107</a>
<a href="#108" id="108">108</a>
<a href="#109" id="109">109</a>
<a href="#110" id="110">110</a>
<a href="#111" id="111">111</a>
<a href="#112" id="112">112</a>
<a href="#113" id="113">113</a>
<a href="#114" id="114">114</a>
<a href="#115" id="115">115</a>
<a href="#116" id="116">116</a>
<a href="#117" id="117">117</a>
<a href="#118" id="118">118</a>
<a href="#119" id="119">119</a>
<a href="#120" id="120">120</a>
<a href="#121" id="121">121</a>
<a href="#122" id="122">122</a>
<a href="#123" id="123">123</a>
<a href="#124" id="124">124</a>
<a href="#125" id="125">125</a>
<a href="#126" id="126">126</a>
<a href="#127" id="127">127</a>
<a href="#128" id="128">128</a>
<a href="#129" id="129">129</a>
<a href="#130" id="130">130</a>
<a href="#131" id="131">131</a>
<a href="#132" id="132">132</a>
<a href="#133" id="133">133</a>
<a href="#134" id="134">134</a>
<a href="#135" id="135">135</a>
<a href="#136" id="136">136</a>
<a href="#137" id="137">137</a>
<a href="#138" id="138">138</a>
<a href="#139" id="139">139</a>
<a href="#140" id="140">140</a>
<a href="#141" id="141">141</a>
<a href="#142" id="142">142</a>
<a href="#143" id="143">143</a>
<a href="#144" id="144">144</a>
<a href="#145" id="145">145</a>
<a href="#146" id="146">146</a>
<a href="#147" id="147">147</a>
<a href="#148" id="148">148</a>
<a href="#149" id="149">149</a>
<a href="#150" id="150">150</a>
<a href="#151" id="151">151</a>
<a href="#152" id="152">152</a>
<a href="#153" id="153">153</a>
<a href="#154" id="154">154</a>
<a href="#155" id="155">155</a>
<a href="#156" id="156">156</a>
<a href="#157" id="157">157</a>
<a href="#158" id="158">158</a>
<a href="#159" id="159">159</a>
<a href="#160" id="160">160</a>
<a href="#161" id="161">161</a>
<a href="#162" id="162">162</a>
<a href="#163" id="163">163</a>
<a href="#164" id="164">164</a>
<a href="#165" id="165">165</a>
<a href="#166" id="166">166</a>
<a href="#167" id="167">167</a>
<a href="#168" id="168">168</a>
<a href="#169" id="169">169</a>
<a href="#170" id="170">170</a>
<a href="#171" id="171">171</a>
<a href="#172" id="172">172</a>
<a href="#173" id="173">173</a>
<a href="#174" id="174">174</a>
<a href="#175" id="175">175</a>
<a href="#176" id="176">176</a>
<a href="#177" id="177">177</a>
<a href="#178" id="178">178</a>
<a href="#179" id="179">179</a>
<a href="#180" id="180">180</a>
<a href="#181" id="181">181</a>
<a href="#182" id="182">182</a>
<a href="#183" id="183">183</a>
<a href="#184" id="184">184</a>
<a href="#185" id="185">185</a>
<a href="#186" id="186">186</a>
<a href="#187" id="187">187</a>
<a href="#188" id="188">188</a>
<a href="#189" id="189">189</a>
<a href="#190" id="190">190</a>
<a href="#191" id="191">191</a>
<a href="#192" id="192">192</a>
<a href="#193" id="193">193</a>
<a href="#194" id="194">194</a>
<a href="#195" id="195">195</a>
<a href="#196" id="196">196</a>
<a href="#197" id="197">197</a>
<a href="#198" id="198">198</a>
<a href="#199" id="199">199</a>
<a href="#200" id="200">200</a>
<a href="#201" id="201">201</a>
<a href="#202" id="202">202</a>
<a href="#203" id="203">203</a>
<a href="#204" id="204">204</a>
<a href="#205" id="205">205</a>
<a href="#206" id="206">206</a>
<a href="#207" id="207">207</a>
<a href="#208" id="208">208</a>
<a href="#209" id="209">209</a>
<a href="#210" id="210">210</a>
<a href="#211" id="211">211</a>
<a href="#212" id="212">212</a>
<a href="#213" id="213">213</a>
<a href="#214" id="214">214</a>
<a href="#215" id="215">215</a>
<a href="#216" id="216">216</a>
<a href="#217" id="217">217</a>
<a href="#218" id="218">218</a>
<a href="#219" id="219">219</a>
<a href="#220" id="220">220</a>
<a href="#221" id="221">221</a>
<a href="#222" id="222">222</a>
<a href="#223" id="223">223</a>
<a href="#224" id="224">224</a>
<a href="#225" id="225">225</a>
<a href="#226" id="226">226</a>
<a href="#227" id="227">227</a>
<a href="#228" id="228">228</a>
<a href="#229" id="229">229</a>
<a href="#230" id="230">230</a>
<a href="#231" id="231">231</a>
<a href="#232" id="232">232</a>
<a href="#233" id="233">233</a>
<a href="#234" id="234">234</a>
<a href="#235" id="235">235</a>
<a href="#236" id="236">236</a>
<a href="#237" id="237">237</a>
<a href="#238" id="238">238</a>
<a href="#239" id="239">239</a>
<a href="#240" id="240">240</a>
<a href="#241" id="241">241</a>
<a href="#242" id="242">242</a>
<a href="#243" id="243">243</a>
<a href="#244" id="244">244</a>
<a href="#245" id="245">245</a>
<a href="#246" id="246">246</a>
<a href="#247" id="247">247</a>
<a href="#248" id="248">248</a>
<a href="#249" id="249">249</a>
<a href="#250" id="250">250</a>
<a href="#251" id="251">251</a>
<a href="#252" id="252">252</a>
<a href="#253" id="253">253</a>
<a href="#254" id="254">254</a>
<a href="#255" id="255">255</a>
<a href="#256" id="256">256</a>
<a href="#257" id="257">257</a>
<a href="#258" id="258">258</a>
<a href="#259" id="259">259</a>
<a href="#260" id="260">260</a>
<a href="#261" id="261">261</a>
<a href="#262" id="262">262</a>
<a href="#263" id="263">263</a>
<a href="#264" id="264">264</a>
<a href="#265" id="265">265</a>
<a href="#266" id="266">266</a>
<a href="#267" id="267">267</a>
<a href="#268" id="268">268</a>
<a href="#269" id="269">269</a>
<a href="#270" id="270">270</a>
<a href="#271" id="271">271</a>
<a href="#272" id="272">272</a>
<a href="#273" id="273">273</a>
<a href="#274" id="274">274</a>
<a href="#275" id="275">275</a>
<a href="#276" id="276">276</a>
<a href="#277" id="277">277</a>
<a href="#278" id="278">278</a>
<a href="#279" id="279">279</a>
<a href="#280" id="280">280</a>
<a href="#281" id="281">281</a>
<a href="#282" id="282">282</a>
<a href="#283" id="283">283</a>
<a href="#284" id="284">284</a>
<a href="#285" id="285">285</a>
<a href="#286" id="286">286</a>
<a href="#287" id="287">287</a>
<a href="#288" id="288">288</a>
<a href="#289" id="289">289</a>
<a href="#290" id="290">290</a>
<a href="#291" id="291">291</a>
<a href="#292" id="292">292</a>
<a href="#293" id="293">293</a>
<a href="#294" id="294">294</a>
<a href="#295" id="295">295</a>
<a href="#296" id="296">296</a>
<a href="#297" id="297">297</a>
<a href="#298" id="298">298</a>
<a href="#299" id="299">299</a>
<a href="#300" id="300">300</a>
<a href="#301" id="301">301</a>
<a href="#302" id="302">302</a>
<a href="#303" id="303">303</a>
<a href="#304" id="304">304</a>
<a href="#305" id="305">305</a>
<a href="#306" id="306">306</a>
<a href="#307" id="307">307</a>
<a href="#308" id="308">308</a>
<a href="#309" id="309">309</a>
<a href="#310" id="310">310</a>
<a href="#311" id="311">311</a>
<a href="#312" id="312">312</a>
<a href="#313" id="313">313</a>
<a href="#314" id="314">314</a>
<a href="#315" id="315">315</a>
<a href="#316" id="316">316</a>
<a href="#317" id="317">317</a>
<a href="#318" id="318">318</a>
<a href="#319" id="319">319</a>
<a href="#320" id="320">320</a>
<a href="#321" id="321">321</a>
<a href="#322" id="322">322</a>
<a href="#323" id="323">323</a>
<a href="#324" id="324">324</a>
<a href="#325" id="325">325</a>
<a href="#326" id="326">326</a>
<a href="#327" id="327">327</a>
<a href="#328" id="328">328</a>
<a href="#329" id="329">329</a>
<a href="#330" id="330">330</a>
<a href="#331" id="331">331</a>
<a href="#332" id="332">332</a>
<a href="#333" id="333">333</a>
<a href="#334" id="334">334</a>
<a href="#335" id="335">335</a>
<a href="#336" id="336">336</a>
<a href="#337" id="337">337</a>
<a href="#338" id="338">338</a>
<a href="#339" id="339">339</a>
<a href="#340" id="340">340</a>
<a href="#341" id="341">341</a>
<a href="#342" id="342">342</a>
<a href="#343" id="343">343</a>
<a href="#344" id="344">344</a>
<a href="#345" id="345">345</a>
<a href="#346" id="346">346</a>
<a href="#347" id="347">347</a>
<a href="#348" id="348">348</a>
<a href="#349" id="349">349</a>
<a href="#350" id="350">350</a>
<a href="#351" id="351">351</a>
<a href="#352" id="352">352</a>
<a href="#353" id="353">353</a>
<a href="#354" id="354">354</a>
<a href="#355" id="355">355</a>
<a href="#356" id="356">356</a>
<a href="#357" id="357">357</a>
<a href="#358" id="358">358</a>
<a href="#359" id="359">359</a>
<a href="#360" id="360">360</a>
<a href="#361" id="361">361</a>
<a href="#362" id="362">362</a>
<a href="#363" id="363">363</a>
<a href="#364" id="364">364</a>
<a href="#365" id="365">365</a>
<a href="#366" id="366">366</a>
<a href="#367" id="367">367</a>
<a href="#368" id="368">368</a>
<a href="#369" id="369">369</a>
<a href="#370" id="370">370</a>
<a href="#371" id="371">371</a>
<a href="#372" id="372">372</a>
<a href="#373" id="373">373</a>
<a href="#374" id="374">374</a>
<a href="#375" id="375">375</a>
<a href="#376" id="376">376</a>
<a href="#377" id="377">377</a>
<a href="#378" id="378">378</a>
<a href="#379" id="379">379</a>
<a href="#380" id="380">380</a>
<a href="#381" id="381">381</a>
<a href="#382" id="382">382</a>
<a href="#383" id="383">383</a>
<a href="#384" id="384">384</a>
<a href="#385" id="385">385</a>
<a href="#386" id="386">386</a>
<a href="#387" id="387">387</a>
<a href="#388" id="388">388</a>
<a href="#389" id="389">389</a>
<a href="#390" id="390">390</a>
<a href="#391" id="391">391</a>
<a href="#392" id="392">392</a>
<a href="#393" id="393">393</a>
<a href="#394" id="394">394</a>
<a href="#395" id="395">395</a>
<a href="#396" id="396">396</a>
<a href="#397" id="397">397</a>
<a href="#398" id="398">398</a>
<a href="#399" id="399">399</a>
<a href="#400" id="400">400</a>
<a href="#401" id="401">401</a>
<a href="#402" id="402">402</a>
<a href="#403" id="403">403</a>
<a href="#404" id="404">404</a>
<a href="#405" id="405">405</a>
<a href="#406" id="406">406</a>
<a href="#407" id="407">407</a>
<a href="#408" id="408">408</a>
<a href="#409" id="409">409</a>
<a href="#410" id="410">410</a>
<a href="#411" id="411">411</a>
<a href="#412" id="412">412</a>
<a href="#413" id="413">413</a>
<a href="#414" id="414">414</a>
<a href="#415" id="415">415</a>
<a href="#416" id="416">416</a>
<a href="#417" id="417">417</a>
<a href="#418" id="418">418</a>
<a href="#419" id="419">419</a>
<a href="#420" id="420">420</a>
<a href="#421" id="421">421</a>
<a href="#422" id="422">422</a>
<a href="#423" id="423">423</a>
<a href="#424" id="424">424</a>
<a href="#425" id="425">425</a>
<a href="#426" id="426">426</a>
<a href="#427" id="427">427</a>
<a href="#428" id="428">428</a>
<a href="#429" id="429">429</a>
<a href="#430" id="430">430</a>
<a href="#431" id="431">431</a>
<a href="#432" id="432">432</a>
<a href="#433" id="433">433</a>
<a href="#434" id="434">434</a>
<a href="#435" id="435">435</a>
<a href="#436" id="436">436</a>
<a href="#437" id="437">437</a>
<a href="#438" id="438">438</a>
<a href="#439" id="439">439</a>
<a href="#440" id="440">440</a>
<a href="#441" id="441">441</a>
<a href="#442" id="442">442</a>
<a href="#443" id="443">443</a>
<a href="#444" id="444">444</a>
<a href="#445" id="445">445</a>
<a href="#446" id="446">446</a>
<a href="#447" id="447">447</a>
<a href="#448" id="448">448</a>
<a href="#449" id="449">449</a>
<a href="#450" id="450">450</a>
<a href="#451" id="451">451</a>
<a href="#452" id="452">452</a>
<a href="#453" id="453">453</a>
<a href="#454" id="454">454</a>
<a href="#455" id="455">455</a>
<a href="#456" id="456">456</a>
<a href="#457" id="457">457</a>
<a href="#458" id="458">458</a>
<a href="#459" id="459">459</a>
<a href="#460" id="460">460</a>
<a href="#461" id="461">461</a>
<a href="#462" id="462">462</a>
<a href="#463" id="463">463</a>
<a href="#464" id="464">464</a>
<a href="#465" id="465">465</a>
<a href="#466" id="466">466</a>
<a href="#467" id="467">467</a>
<a href="#468" id="468">468</a>
<a href="#469" id="469">469</a>
<a href="#470" id="470">470</a>
<a href="#471" id="471">471</a>
<a href="#472" id="472">472</a>
<a href="#473" id="473">473</a>
<a href="#474" id="474">474</a>
<a href="#475" id="475">475</a>
<a href="#476" id="476">476</a>
<a href="#477" id="477">477</a>
<a href="#478" id="478">478</a>
<a href="#479" id="479">479</a>
<a href="#480" id="480">480</a>
<a href="#481" id="481">481</a>
<a href="#482" id="482">482</a>
<a href="#483" id="483">483</a>
<a href="#484" id="484">484</a>
<a href="#485" id="485">485</a>
<a href="#486" id="486">486</a>
<a href="#487" id="487">487</a>
<a href="#488" id="488">488</a>
<a href="#489" id="489">489</a>
<a href="#490" id="490">490</a>
<a href="#491" id="491">491</a>
<a href="#492" id="492">492</a>
<a href="#493" id="493">493</a>
<a href="#494" id="494">494</a>
<a href="#495" id="495">495</a>
<a href="#496" id="496">496</a>
<a href="#497" id="497">497</a>
<a href="#498" id="498">498</a>
<a href="#499" id="499">499</a>
<a href="#500" id="500">500</a>
<a href="#501" id="501">501</a>
<a href="#502" id="502">502</a>
<a href="#503" id="503">503</a>
<a href="#504" id="504">504</a>
<a href="#505" id="505">505</a>
<a href="#506" id="506">506</a>
<a href="#507" id="507">507</a>
<a href="#508" id="508">508</a>
<a href="#509" id="509">509</a>
<a href="#510" id="510">510</a>
<a href="#511" id="511">511</a>
<a href="#512" id="512">512</a>
<a href="#513" id="513">513</a>
<a href="#514" id="514">514</a>
<a href="#515" id="515">515</a>
<a href="#516" id="516">516</a>
<a href="#517" id="517">517</a>
<a href="#518" id="518">518</a>
<a href="#519" id="519">519</a>
<a href="#520" id="520">520</a>
<a href="#521" id="521">521</a>
<a href="#522" id="522">522</a>
<a href="#523" id="523">523</a>
<a href="#524" id="524">524</a>
<a href="#525" id="525">525</a>
<a href="#526" id="526">526</a>
<a href="#527" id="527">527</a>
<a href="#528" id="528">528</a>
<a href="#529" id="529">529</a>
<a href="#530" id="530">530</a>
<a href="#531" id="531">531</a>
<a href="#532" id="532">532</a>
<a href="#533" id="533">533</a>
<a href="#534" id="534">534</a>
<a href="#535" id="535">535</a>
<a href="#536" id="536">536</a>
<a href="#537" id="537">537</a>
<a href="#538" id="538">538</a>
<a href="#539" id="539">539</a>
<a href="#540" id="540">540</a>
<a href="#541" id="541">541</a>
<a href="#542" id="542">542</a>
<a href="#543" id="543">543</a>
<a href="#544" id="544">544</a>
<a href="#545" id="545">545</a>
<a href="#546" id="546">546</a>
<a href="#547" id="547">547</a>
<a href="#548" id="548">548</a>
<a href="#549" id="549">549</a>
<a href="#550" id="550">550</a>
<a href="#551" id="551">551</a>
<a href="#552" id="552">552</a>
<a href="#553" id="553">553</a>
<a href="#554" id="554">554</a>
</pre></div><pre class="rust"><code><span class="kw">use </span>core::{cell::UnsafeCell, mem};

<span class="kw">use </span>alloc::vec::Vec;

<span class="kw">use crate</span>::{
    core::{indices::MemIdx, little_endian::LittleEndianBytes},
    rw_spinlock::RwSpinLock,
    RuntimeError,
};

<span class="doccomment">/// Implementation of the linear memory suitable for concurrent access
///
/// Implements the base for the instructions described in
/// &lt;https://webassembly.github.io/spec/core/exec/instructions.html#memory-instructions&gt;.
///
/// This linear memory implementation internally relies on a `Vec&lt;UnsafeCell&lt;u8&gt;&gt;`. Thus, the atomic
/// unit of information for it is a byte (`u8`). All access to the linear memory internally occurs
/// through pointers, avoiding the creation of shared and mut refs to the internal data completely.
/// This avoids undefined behavior, except for the race-condition inherent to concurrent writes.
/// Because of this, the [`LinearMemory::store`] function does not require `&amp;mut self` -- `&amp;self`
/// suffices.
///
/// # Notes on overflowing
///
/// All operations that rely on accessing `n` bytes starting at `index` in the linear memory have to
/// perform bounds checking. Thus they always have to ensure that `n + index &lt; linear_memory.len()`
/// holds true (e.g. `n + index - 1` must be a valid index into `linear_memory`). However,
/// writing that check as is bears the danger of an overflow, assuming that `n`, `index` and
/// `linear_memory.len()` are the same given integer type, `n + index` can overflow, resulting in
/// the check passing despite the access being out of bounds!
///
/// To avoid this, the bounds checks are carefully ordered to avoid any overflows:
///
/// - First we check, that `n &lt;= linear_memory.len()` holds true, ensuring that the amount of bytes
///   to be accessed is indeed smaller than or equal to the linear memory's size. If this does not
///   hold true, continuation of the operation will yield out of bounds access in any case.
/// - Then, as a second check, we verify that `index &lt;= linear_memory.len() - n`. This way we
///   avoid the overflow, as there is no addition. The subtraction in the left hand can not
///   underflow, due to the previous check (which asserts that `n` is smaller than or equal to
///   `linear_memory.len()`).
///
/// Combined in the given order, these two checks enable bounds checking without risking any
/// overflow or underflow, provided that `n`, `index` and `linear_memory.len()` are of the same
/// integer type.
///
/// # Notes on locking
///
/// The internal data vector of the [`LinearMemory`] is wrapped in a [`RwSpinLock`]. Despite the
/// name, writes to the linear memory do not require an acquisition of a write lock. Writes are
/// implemented through a shared ref to the internal vector, with an `UnsafeCell` to achieve
/// interior mutability.
///
/// However, linear memory can grow. As the linear memory is implemented via a [`Vec`], a grow can
/// result in the vector's internal data buffer to be copied over to a bigger, fresh allocation.
/// The old buffer is then freed. Combined with concurrent mutable access, this can cause
/// use-after-free. To avoid this, a grow operation of the linear memory acquires a write lock,
/// blocking all read/write to the linear memory inbetween.
///
/// # Unsafe Note
///
/// Raw pointer access it required, because concurent mutation of the linear memory might happen
/// (consider the threading proposal for WASM, where mutliple WASM threads access the same linear
/// memory at the same time). The inherent race condition results in UB w/r/t the state of the `u8`s
/// in the inner data. However, this is tolerable, e.g. avoiding race conditions on the state of the
/// linear memory can not be the task of the interpreter, but has to be fulfilled by the interpreted
/// bytecode itself.
</span><span class="comment">// TODO if a memmap like operation is available, the linear memory implementation can be optimized brutally. Out-of-bound access can be mapped to userspace handled page-faults, e.g. the MMU takes over that responsibility of catching out of bounds. Grow can happen without copying of data, by mapping new pages consecutively after the current final page of the linear memory.
</span><span class="kw">pub struct </span>LinearMemory&lt;<span class="kw">const </span>PAGE_SIZE: usize = { <span class="kw">crate</span>::Limits::MEM_PAGE_SIZE <span class="kw">as </span>usize }&gt; {
    inner_data: RwSpinLock&lt;Vec&lt;UnsafeCell&lt;u8&gt;&gt;&gt;,
}

<span class="doccomment">/// Type to express the page count
</span><span class="kw">pub type </span>PageCountTy = u16;

<span class="kw">impl</span>&lt;<span class="kw">const </span>PAGE_SIZE: usize&gt; LinearMemory&lt;PAGE_SIZE&gt; {
    <span class="doccomment">/// Size of a page in the linear memory, measured in bytes
    ///
    /// The WASM specification demands a page size of 64 KiB, that is `65536` bytes:
    /// &lt;https://webassembly.github.io/spec/core/exec/runtime.html?highlight=page#memory-instances&gt;
    </span><span class="kw">const </span>PAGE_SIZE: usize = PAGE_SIZE;

    <span class="doccomment">/// Create a new, empty [`LinearMemory`]
    </span><span class="kw">pub fn </span>new() -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{
            inner_data: RwSpinLock::new(Vec::new()),
        }
    }

    <span class="doccomment">/// Create a new, empty [`LinearMemory`]
    </span><span class="kw">pub fn </span>new_with_initial_pages(pages: PageCountTy) -&gt; <span class="self">Self </span>{
        <span class="kw">let </span>size_bytes = <span class="self">Self</span>::PAGE_SIZE * pages <span class="kw">as </span>usize;
        <span class="kw">let </span><span class="kw-2">mut </span>data = Vec::with_capacity(size_bytes);
        data.resize_with(size_bytes, || UnsafeCell::new(<span class="number">0</span>));

        <span class="self">Self </span>{
            inner_data: RwSpinLock::new(data),
        }
    }

    <span class="doccomment">/// Grow the [`LinearMemory`] by a number of pages
    </span><span class="kw">pub fn </span>grow(<span class="kw-2">&amp;</span><span class="self">self</span>, pages_to_add: PageCountTy) {
        <span class="kw">let </span><span class="kw-2">mut </span>lock_guard = <span class="self">self</span>.inner_data.write();
        <span class="kw">let </span>prior_length_bytes = lock_guard.len();
        <span class="kw">let </span>new_length_bytes = prior_length_bytes + <span class="self">Self</span>::PAGE_SIZE * pages_to_add <span class="kw">as </span>usize;
        lock_guard.resize_with(new_length_bytes, || UnsafeCell::new(<span class="number">0</span>));
    }

    <span class="doccomment">/// Get the number of pages currently allocated to this [`LinearMemory`]
    </span><span class="kw">pub fn </span>pages(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; PageCountTy {
        PageCountTy::try_from(<span class="self">self</span>.inner_data.read().len() / PAGE_SIZE).unwrap()
    }

    <span class="doccomment">/// Get the length in bytes currently allocated to this [`LinearMemory`]
    </span><span class="comment">// TODO remove this op
    </span><span class="kw">pub fn </span>len(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; usize {
        <span class="self">self</span>.inner_data.read().len()
    }

    <span class="doccomment">/// At a given index, store a datum in the [`LinearMemory`]
    </span><span class="kw">pub fn </span>store&lt;<span class="kw">const </span>N: usize, T: LittleEndianBytes&lt;N&gt;&gt;(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        index: MemIdx,
        value: T,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;(), RuntimeError&gt; {
        <span class="kw">let </span>value_size = mem::size_of::&lt;T&gt;();

        <span class="comment">// Unless someone implementes something wrong like `impl LittleEndianBytes&lt;3&gt; for f64`, this
        // check is already guaranteed at the type level. Therefore only a debug_assert.
        </span><span class="macro">debug_assert_eq!</span>(value_size, N, <span class="string">"value size must match const generic N"</span>);

        <span class="kw">let </span>lock_guard = <span class="self">self</span>.inner_data.read();

        <span class="comment">// A value must fit into the linear memory
        </span><span class="kw">if </span>value_size &gt; lock_guard.len() {
            <span class="macro">error!</span>(<span class="string">"value does not fit into linear memory"</span>);
            <span class="kw">return </span><span class="prelude-val">Err</span>(RuntimeError::MemoryAccessOutOfBounds);
        }

        <span class="comment">// The following statement must be true
        // `index + value_size &lt;= lock_guard.len()`
        // This check verifies it, while avoiding the possible overflow. The subtraction can not
        // underflow because of the previous check.

        </span><span class="kw">if </span>(index) &gt; lock_guard.len() - value_size {
            <span class="macro">error!</span>(<span class="string">"value write would extend beyond the end of the linear memory"</span>);
            <span class="kw">return </span><span class="prelude-val">Err</span>(RuntimeError::MemoryAccessOutOfBounds);
        }

        <span class="comment">// TODO this unwrap can not fail, maybe use unwrap_unchecked?
        </span><span class="kw">let </span>ptr = lock_guard.get(index).unwrap().get();
        <span class="kw">let </span>bytes = value.to_le_bytes(); <span class="comment">//

        // Safety argument:
        //
        // - nonoverlapping is guaranteed, because `src` is a pointer to a stack allocated array,
        //   while the destination is heap allocated Vec
        // - the first check above guarantee that `src` fits into the destination
        // - the second check above guarantees that even with the offset in `index`, `src` does not
        //   extend beyond the destinations last `UnsafeCell&lt;u8&gt;`
        // - the use of `UnsafeCell` avoids any `&amp;` or `&amp;mut` to ever be created on any of the `u8`s
        //   contained in the `UnsafeCell`s, so no UB is created through the existence of unsound
        //   references
        </span><span class="kw">unsafe </span>{ ptr.copy_from_nonoverlapping(bytes.as_ref().as_ptr(), value_size) }

        <span class="prelude-val">Ok</span>(())
    }

    <span class="doccomment">/// From a given index, load a datum in the [`LinearMemory`]
    </span><span class="kw">pub fn </span>load&lt;<span class="kw">const </span>N: usize, T: LittleEndianBytes&lt;N&gt;&gt;(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        index: MemIdx,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;T, RuntimeError&gt; {
        <span class="kw">let </span>value_size = mem::size_of::&lt;T&gt;();

        <span class="comment">// Unless someone implementes something wrong like `LittleEndianBytes&lt;3&gt; for i8`, this
        // check is already guaranteed at the type level. Therefore only a debug_assert.
        </span><span class="macro">debug_assert_eq!</span>(value_size, N, <span class="string">"value size must match const generic N"</span>);

        <span class="kw">let </span>lock_guard = <span class="self">self</span>.inner_data.read();

        <span class="comment">// A value must fit into the linear memory
        </span><span class="kw">if </span>value_size &gt; lock_guard.len() {
            <span class="macro">error!</span>(<span class="string">"value does not fit into linear memory"</span>);
            <span class="kw">return </span><span class="prelude-val">Err</span>(RuntimeError::MemoryAccessOutOfBounds);
        }

        <span class="comment">// The following statement must be true
        // `index + value_size &lt;= lock_guard.len()`
        // This check verifies it, while avoiding the possible overflow. The subtraction can not
        // underflow because of the previous assert.

        </span><span class="kw">if </span>(index) &gt; lock_guard.len() - value_size {
            <span class="macro">error!</span>(<span class="string">"value read would extend beyond the end of the linear_memory"</span>);
            <span class="kw">return </span><span class="prelude-val">Err</span>(RuntimeError::MemoryAccessOutOfBounds);
        }

        <span class="kw">let </span>ptr = lock_guard.get(index).unwrap().get();
        <span class="kw">let </span><span class="kw-2">mut </span>bytes = [<span class="number">0</span>; N];

        <span class="comment">// Safety argument:
        //
        // - nonoverlapping is guaranteed, because `dest` is a pointer to a stack allocated array,
        //   while the source is heap allocated Vec
        // - the first assert above guarantee that source is bigger than `dest`
        // - the second assert above guarantees that even with the offset in `index`, `dest` does
        //   not extend beyond the destinations last `UnsafeCell&lt;u8&gt;` in source
        // - the use of `UnsafeCell` avoids any `&amp;` or `&amp;mut` to ever be created on any of the `u8`s
        //   contained in the `UnsafeCell`s, so no UB is created through the existence of unsound
        //   references
        </span><span class="kw">unsafe </span>{ ptr.copy_to_nonoverlapping(bytes.as_mut_ptr(), bytes.len()) };
        <span class="prelude-val">Ok</span>(T::from_le_bytes(bytes))
    }

    <span class="doccomment">/// Implementation of the behavior described in
    /// &lt;https://webassembly.github.io/spec/core/exec/instructions.html#xref-syntax-instructions-syntax-instr-memory-mathsf-memory-fill&gt;.
    /// Note, that the WASM spec defines the behavior by recursion, while our implementation uses
    /// the memset like [`core::ptr::write_bytes`].
    </span><span class="kw">pub fn </span>fill(<span class="kw-2">&amp;</span><span class="self">self</span>, index: MemIdx, data_byte: u8, count: MemIdx) -&gt; <span class="prelude-ty">Result</span>&lt;(), RuntimeError&gt; {
        <span class="kw">if </span>count == <span class="number">0 </span>{
            <span class="kw">return </span><span class="prelude-val">Ok</span>(());
        }

        <span class="kw">let </span>lock_guard = <span class="self">self</span>.inner_data.read();

        <span class="kw">if </span>count &gt; lock_guard.len() {
            <span class="macro">error!</span>(<span class="string">"fill count is bigger than the linear memory"</span>);
            <span class="kw">return </span><span class="prelude-val">Err</span>(RuntimeError::MemoryAccessOutOfBounds);
        }

        <span class="kw">if </span>index &gt; lock_guard.len() - count {
            <span class="macro">error!</span>(<span class="string">"fill extends beyond the linear memory's end"</span>);
            <span class="kw">return </span><span class="prelude-val">Err</span>(RuntimeError::MemoryAccessOutOfBounds);
        }

        <span class="kw">let </span>ptr = lock_guard[index].get();
        <span class="kw">unsafe </span>{
            ptr.write_bytes(data_byte, count);
        }

        <span class="prelude-val">Ok</span>(())
    }

    <span class="doccomment">/// Copy `count` bytes from one region in the linear memory to another region in the same or a
    /// different linear memory
    ///
    /// - Both regions may overlap
    /// - Copies the `count` bytes starting from `source_index`, overwriting the `count` bytes
    ///   starting from `destination_index`
    </span><span class="kw">pub fn </span>copy(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        destination_index: MemIdx,
        source_mem: <span class="kw-2">&amp;</span><span class="self">Self</span>,
        source_index: MemIdx,
        count: MemIdx,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;(), RuntimeError&gt; {
        <span class="kw">if </span>count == <span class="number">0 </span>{
            <span class="kw">return </span><span class="prelude-val">Ok</span>(());
        }

        <span class="comment">// self is the destination
        </span><span class="kw">let </span>lock_guard_self = <span class="self">self</span>.inner_data.read();

        <span class="comment">// other is the source
        </span><span class="kw">let </span>lock_guard_other = source_mem.inner_data.read();

        <span class="comment">// check destination for out of bounds access
        </span><span class="kw">if </span>count &gt; lock_guard_self.len() {
            <span class="macro">error!</span>(<span class="string">"copy count is bigger than the destination linear memory"</span>);
            <span class="kw">return </span><span class="prelude-val">Err</span>(RuntimeError::MemoryAccessOutOfBounds);
        }

        <span class="kw">if </span>destination_index &gt; lock_guard_self.len() - count {
            <span class="macro">error!</span>(<span class="string">"copy destination extends beyond the linear memory's end"</span>);
            <span class="kw">return </span><span class="prelude-val">Err</span>(RuntimeError::MemoryAccessOutOfBounds);
        }

        <span class="comment">// check source for out of bounds access
        </span><span class="kw">if </span>count &gt; lock_guard_other.len() {
            <span class="macro">error!</span>(<span class="string">"copy count is bigger than the source linear memory"</span>);
            <span class="kw">return </span><span class="prelude-val">Err</span>(RuntimeError::MemoryAccessOutOfBounds);
        }

        <span class="kw">if </span>source_index &gt; lock_guard_other.len() - count {
            <span class="macro">error!</span>(<span class="string">"copy source extends beyond the linear memory's end"</span>);
            <span class="kw">return </span><span class="prelude-val">Err</span>(RuntimeError::MemoryAccessOutOfBounds);
        }

        <span class="comment">// acquire pointers
        </span><span class="kw">let </span>destination_ptr = lock_guard_self[destination_index].get();
        <span class="kw">let </span>source_ptr = lock_guard_other[source_index].get();

        <span class="comment">// copy the data
        </span><span class="kw">unsafe </span>{
            <span class="comment">// TODO investigate if it is worth to use a conditional `copy_from_nonoverlapping`
            // if the non-overlapping can be confirmed (and the count is bigger than a certain
            // threshold).
            </span>destination_ptr.copy_from(source_ptr, count);
        }

        <span class="prelude-val">Ok</span>(())
    }

    <span class="comment">// Rationale behind having `source_index` and `count` when the callsite could also just create a subslice for `source_data`? Have all the index error checks in one place.
    </span><span class="kw">pub fn </span>init(
        <span class="kw-2">&amp;</span><span class="self">self</span>,
        destination_index: MemIdx,
        source_data: <span class="kw-2">&amp;</span>[u8],
        source_index: MemIdx,
        count: MemIdx,
    ) -&gt; <span class="prelude-ty">Result</span>&lt;(), RuntimeError&gt; {
        <span class="kw">if </span>count == <span class="number">0 </span>{
            <span class="kw">return </span><span class="prelude-val">Ok</span>(());
        }

        <span class="kw">let </span>lock_guard_self = <span class="self">self</span>.inner_data.read();
        <span class="kw">let </span>data_len = source_data.len();

        <span class="comment">// check destination for out of bounds access
        </span><span class="kw">if </span>count &gt; lock_guard_self.len() {
            <span class="macro">error!</span>(<span class="string">"init count is bigger than the linear memory"</span>);
            <span class="kw">return </span><span class="prelude-val">Err</span>(RuntimeError::MemoryAccessOutOfBounds);
        }

        <span class="kw">if </span>destination_index &gt; lock_guard_self.len() - count {
            <span class="macro">error!</span>(<span class="string">"init extends beyond the linear memory's end"</span>);
            <span class="kw">return </span><span class="prelude-val">Err</span>(RuntimeError::MemoryAccessOutOfBounds);
        }

        <span class="comment">// check source for out of bounds access
        </span><span class="kw">if </span>count &gt; data_len {
            <span class="macro">error!</span>(<span class="string">"init count is bigger than the data instance"</span>);
            <span class="kw">return </span><span class="prelude-val">Err</span>(RuntimeError::MemoryAccessOutOfBounds);
        }

        <span class="kw">if </span>source_index &gt; data_len - count {
            <span class="macro">error!</span>(<span class="string">"init source extends beyond the data instance's end"</span>);
            <span class="kw">return </span><span class="prelude-val">Err</span>(RuntimeError::MemoryAccessOutOfBounds);
        }

        <span class="comment">// acquire pointers
        </span><span class="kw">let </span>destination_ptr = lock_guard_self[destination_index].get();
        <span class="kw">let </span>source_ptr = <span class="kw-2">&amp;</span>source_data[source_index];

        <span class="comment">// copy the data
        </span><span class="kw">unsafe </span>{
            destination_ptr.copy_from_nonoverlapping(source_ptr, count);
        }

        <span class="prelude-val">Ok</span>(())
    }
}

<span class="kw">impl</span>&lt;<span class="kw">const </span>PAGE_SIZE: usize&gt; core::fmt::Debug <span class="kw">for </span>LinearMemory&lt;PAGE_SIZE&gt; {
    <span class="kw">fn </span>fmt(<span class="kw-2">&amp;</span><span class="self">self</span>, f: <span class="kw-2">&amp;mut </span>core::fmt::Formatter&lt;<span class="lifetime">'_</span>&gt;) -&gt; core::fmt::Result {
        <span class="macro">write!</span>(f, <span class="string">"LinearMemory {{ inner_data: [ "</span>)<span class="question-mark">?</span>;
        <span class="kw">let </span>lock_guard = <span class="self">self</span>.inner_data.read();
        <span class="kw">let </span><span class="kw-2">mut </span>iter = lock_guard.iter();

        <span class="kw">if let </span><span class="prelude-val">Some</span>(first_byte_uc) = iter.next() {
            <span class="macro">write!</span>(f, <span class="string">"{}"</span>, <span class="kw">unsafe </span>{ <span class="kw-2">*</span>first_byte_uc.get() })<span class="question-mark">?</span>;
        }

        <span class="kw">for </span>uc <span class="kw">in </span>iter {
            <span class="comment">// Safety argument:
            //
            // TODO
            </span><span class="kw">let </span>byte = <span class="kw">unsafe </span>{ <span class="kw-2">*</span>uc.get() };

            <span class="macro">write!</span>(f, <span class="string">", {byte}"</span>)<span class="question-mark">?</span>;
        }
        <span class="macro">write!</span>(f, <span class="string">" ] }}"</span>)
    }
}

<span class="kw">impl</span>&lt;<span class="kw">const </span>PAGE_SIZE: usize&gt; Default <span class="kw">for </span>LinearMemory&lt;PAGE_SIZE&gt; {
    <span class="kw">fn </span>default() -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>::new()
    }
}

<span class="attr">#[cfg(test)]
</span><span class="kw">mod </span>test {
    <span class="kw">use </span>alloc::format;

    <span class="kw">use super</span>::<span class="kw-2">*</span>;

    <span class="kw">const </span>PAGE_SIZE: usize = <span class="number">1 </span>&lt;&lt; <span class="number">8</span>;
    <span class="kw">const </span>PAGES: PageCountTy = <span class="number">2</span>;

    <span class="attr">#[test]
    </span><span class="kw">fn </span>new_constructor() {
        <span class="kw">let </span>lin_mem = LinearMemory::&lt;PAGE_SIZE&gt;::new();
        <span class="macro">assert_eq!</span>(lin_mem.pages(), <span class="number">0</span>);
    }

    <span class="attr">#[test]
    </span><span class="kw">fn </span>new_grow() {
        <span class="kw">let </span>lin_mem = LinearMemory::&lt;PAGE_SIZE&gt;::new();
        lin_mem.grow(<span class="number">1</span>);
        <span class="macro">assert_eq!</span>(lin_mem.pages(), <span class="number">1</span>);
    }

    <span class="attr">#[test]
    </span><span class="kw">fn </span>debug_print() {
        <span class="kw">let </span>lin_mem = LinearMemory::&lt;PAGE_SIZE&gt;::new_with_initial_pages(<span class="number">1</span>);
        <span class="macro">assert_eq!</span>(lin_mem.pages(), <span class="number">1</span>);

        <span class="kw">let </span>expected_length = <span class="string">"LinearMemory { inner_data: [  ] }"</span>.len() + PAGE_SIZE * <span class="string">"0, "</span>.len();
        <span class="kw">let </span>tol = <span class="number">2</span>;

        <span class="kw">let </span>debug_repr = <span class="macro">format!</span>(<span class="string">"{lin_mem:?}"</span>);
        <span class="kw">let </span>lower_bound = expected_length - tol;
        <span class="kw">let </span>upper_bound = expected_length + tol;
        <span class="macro">assert!</span>((lower_bound..upper_bound).contains(<span class="kw-2">&amp;</span>debug_repr.len()));
    }

    <span class="attr">#[test]
    </span><span class="kw">fn </span>roundtrip_normal_range_i8_neg127() {
        <span class="kw">let </span>x: i8 = -<span class="number">127</span>;
        <span class="kw">let </span>highest_legal_offset = PAGE_SIZE - mem::size_of::&lt;i8&gt;();
        <span class="kw">for </span>offset <span class="kw">in </span><span class="number">0</span>..MemIdx::try_from(highest_legal_offset).unwrap() {
            <span class="kw">let </span>lin_mem = LinearMemory::&lt;PAGE_SIZE&gt;::new_with_initial_pages(PAGES);

            lin_mem.store(offset, x).unwrap();

            <span class="macro">assert_eq!</span>(
                lin_mem
                    .load::&lt;{ core::mem::size_of::&lt;i8&gt;() }, i8&gt;(offset)
                    .unwrap(),
                x,
                <span class="string">"load store roundtrip for {x:?} failed!"
            </span>);
        }
    }

    <span class="attr">#[test]
    </span><span class="kw">fn </span>roundtrip_normal_range_f32_13() {
        <span class="kw">let </span>x: f32 = <span class="number">13.0</span>;
        <span class="kw">let </span>highest_legal_offset = PAGE_SIZE - mem::size_of::&lt;f32&gt;();
        <span class="kw">for </span>offset <span class="kw">in </span><span class="number">0</span>..MemIdx::try_from(highest_legal_offset).unwrap() {
            <span class="kw">let </span>lin_mem = LinearMemory::&lt;PAGE_SIZE&gt;::new_with_initial_pages(PAGES);

            lin_mem.store(offset, x).unwrap();

            <span class="macro">assert_eq!</span>(
                lin_mem
                    .load::&lt;{ core::mem::size_of::&lt;f32&gt;() }, f32&gt;(offset)
                    .unwrap(),
                x,
                <span class="string">"load store roundtrip for {x:?} failed!"
            </span>);
        }
    }

    <span class="attr">#[test]
    </span><span class="kw">fn </span>roundtrip_normal_range_f64_min() {
        <span class="kw">let </span>x: f64 = f64::MIN;
        <span class="kw">let </span>highest_legal_offset = PAGE_SIZE - mem::size_of::&lt;f64&gt;();
        <span class="kw">for </span>offset <span class="kw">in </span><span class="number">0</span>..MemIdx::try_from(highest_legal_offset).unwrap() {
            <span class="kw">let </span>lin_mem = LinearMemory::&lt;PAGE_SIZE&gt;::new_with_initial_pages(PAGES);

            lin_mem.store(offset, x).unwrap();

            <span class="macro">assert_eq!</span>(
                lin_mem
                    .load::&lt;{ core::mem::size_of::&lt;f64&gt;() }, f64&gt;(offset)
                    .unwrap(),
                x,
                <span class="string">"load store roundtrip for {x:?} failed!"
            </span>);
        }
    }

    <span class="attr">#[test]
    </span><span class="kw">fn </span>roundtrip_normal_range_f64_nan() {
        <span class="kw">let </span>x: f64 = f64::NAN;
        <span class="kw">let </span>highest_legal_offset = PAGE_SIZE - mem::size_of::&lt;f64&gt;();
        <span class="kw">for </span>offset <span class="kw">in </span><span class="number">0</span>..MemIdx::try_from(highest_legal_offset).unwrap() {
            <span class="kw">let </span>lin_mem = LinearMemory::&lt;PAGE_SIZE&gt;::new_with_initial_pages(PAGES);

            lin_mem.store(offset, x).unwrap();

            <span class="macro">assert!</span>(
                lin_mem
                    .load::&lt;{ core::mem::size_of::&lt;f64&gt;() }, f64&gt;(offset)
                    .unwrap()
                    .is_nan(),
                <span class="string">"load store roundtrip for {x:?} failed!"
            </span>);
        }
    }

    <span class="attr">#[test]
    #[should_panic(
        expected = <span class="string">"called `Result::unwrap()` on an `Err` value: MemoryAccessOutOfBounds"
    </span>)]
    </span><span class="kw">fn </span>store_out_of_range_u128_max() {
        <span class="kw">let </span>x: u128 = u128::MAX;
        <span class="kw">let </span>pages = <span class="number">1</span>;
        <span class="kw">let </span>lowest_illegal_offset = PAGE_SIZE - mem::size_of::&lt;u128&gt;() + <span class="number">1</span>;
        <span class="kw">let </span>lowest_illegal_offset = MemIdx::try_from(lowest_illegal_offset).unwrap();
        <span class="kw">let </span>lin_mem = LinearMemory::&lt;PAGE_SIZE&gt;::new_with_initial_pages(pages);

        lin_mem.store(lowest_illegal_offset, x).unwrap();
    }

    <span class="attr">#[test]
    #[should_panic(
        expected = <span class="string">"called `Result::unwrap()` on an `Err` value: MemoryAccessOutOfBounds"
    </span>)]
    </span><span class="kw">fn </span>store_empty_lineaer_memory_u8() {
        <span class="kw">let </span>x: u8 = u8::MAX;
        <span class="kw">let </span>pages = <span class="number">0</span>;
        <span class="kw">let </span>lowest_illegal_offset = PAGE_SIZE - mem::size_of::&lt;u8&gt;() + <span class="number">1</span>;
        <span class="kw">let </span>lowest_illegal_offset = MemIdx::try_from(lowest_illegal_offset).unwrap();
        <span class="kw">let </span>lin_mem = LinearMemory::&lt;PAGE_SIZE&gt;::new_with_initial_pages(pages);

        lin_mem.store(lowest_illegal_offset, x).unwrap();
    }

    <span class="attr">#[test]
    #[should_panic(
        expected = <span class="string">"called `Result::unwrap()` on an `Err` value: MemoryAccessOutOfBounds"
    </span>)]
    </span><span class="kw">fn </span>load_out_of_range_u128_max() {
        <span class="kw">let </span>pages = <span class="number">1</span>;
        <span class="kw">let </span>lowest_illegal_offset = PAGE_SIZE - mem::size_of::&lt;u128&gt;() + <span class="number">1</span>;
        <span class="kw">let </span>lowest_illegal_offset = MemIdx::try_from(lowest_illegal_offset).unwrap();
        <span class="kw">let </span>lin_mem = LinearMemory::&lt;PAGE_SIZE&gt;::new_with_initial_pages(pages);

        <span class="kw">let </span>_x: u128 = lin_mem.load(lowest_illegal_offset).unwrap();
    }

    <span class="attr">#[test]
    #[should_panic(
        expected = <span class="string">"called `Result::unwrap()` on an `Err` value: MemoryAccessOutOfBounds"
    </span>)]
    </span><span class="kw">fn </span>load_empty_lineaer_memory_u8() {
        <span class="kw">let </span>pages = <span class="number">0</span>;
        <span class="kw">let </span>lowest_illegal_offset = PAGE_SIZE - mem::size_of::&lt;u8&gt;() + <span class="number">1</span>;
        <span class="kw">let </span>lowest_illegal_offset = MemIdx::try_from(lowest_illegal_offset).unwrap();
        <span class="kw">let </span>lin_mem = LinearMemory::&lt;PAGE_SIZE&gt;::new_with_initial_pages(pages);

        <span class="kw">let </span>_x: u8 = lin_mem.load(lowest_illegal_offset).unwrap();
    }

    <span class="attr">#[test]
    #[should_panic]
    </span><span class="kw">fn </span>copy_out_of_bounds() {
        <span class="kw">let </span>lin_mem_0 = LinearMemory::&lt;PAGE_SIZE&gt;::new_with_initial_pages(<span class="number">2</span>);
        <span class="kw">let </span>lin_mem_1 = LinearMemory::&lt;PAGE_SIZE&gt;::new_with_initial_pages(<span class="number">1</span>);
        lin_mem_0.copy(<span class="number">0</span>, <span class="kw-2">&amp;</span>lin_mem_1, <span class="number">0</span>, PAGE_SIZE + <span class="number">1</span>).unwrap();
    }
}
</code></pre></div></section></main></body></html>