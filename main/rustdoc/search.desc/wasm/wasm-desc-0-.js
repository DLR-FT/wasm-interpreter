searchState.loadedDescShard("wasm", 0, "An active element segment’s type and its table’s type …\nAn expr in the code section has trailing instructions …\nThe data count specified in the data count section and the …\nMultiple exports share the same name\nHappens when a definition would cause an extern to be …\nAn <code>else</code> instruction was found while not inside an <code>if</code> block.\nThe end of the binary file was reached unexpectedly.\nContains the error value\nAn alignment of some memory instruction is invalid\nAn opt-in error type useful for merging all error types of …\nA reference type was expected to be on the stack, but a …\ncommon convention functions defined for lists of …\n…\nThe number of module exports did not match the number of …\nThe lengths of the function and code sections must match.\nA function was invoked with incorrect parameters or return …\nA marker error for host functions to return, in case they …\nA host function returned the <code>HaltExecutionError</code>, which …\n33-bit signed integers are sometimes used to encode …\nAn <code>end</code> for a matching <code>if</code> instruction was found, but there …\nAn indirect call to a table with does not store function …\nRepresents a successful, possibly fueled instantiation of …\nThe binary format version at the start of the Wasm …\nA custom section contains more bytes than its section …\nAn index for a data segment is invalid.\nAn index for an element segment is invalid.\nAn index for a function is invalid.\nAn index for a global is invalid.\nAn index for a label is invalid.\nAn index for a lane of some vector type is invalid.\nAn index for a local is invalid.\nThe magic number at the start of the Wasm bytecode is …\nAn index for a memory is invalid.\nThe select instructions may work with multiple values in …\nThe function signature of the start function is invalid. …\nAn index for a table is invalid.\nAn index for a type is invalid.\nA checked method of a <code>Linker</code> was used, even though that …\nBlock types use a special 33-bit signed integer for …\nThe discriminator of an element kind is malformed.\nThe discriminator of an export description is malformed.\nThe discriminator of a function type is malformed.\nThe discriminator of an import description is malformed.\nThe discriminator of a limits type is malformed.\nThe min field of a limits type is larger than the max …\nThe discriminator of a mut type is malformed.\nThe discriminator of a number type is malformed.\nThe discriminator of a reference type is malformed.\nThe type of a section is malformed.\nA UTF-8 string is malformed.\nA valtype is malformed because it is neither a number, …\nA variable-length integer was read but it overflowed.\nThe discriminator of a vector type is malformed.\nAn access to a memory or data was out of bounds.\nThe memory size specified by a mem type exceeds the …\nA <code>table.copy</code> instruction referenced two tables that store …\nA <code>table.init</code> instruction specified a table and an element …\nAn expected reference type did not match the actual …\nAn attempt has been made to mutate a const global\n…\nContains the success value\nFueled execution that is not resumable has ran out of fuel.\n…\nWhen a is referenced in the code section it must be …\nIt was attempted to register a symbol under a name for …\nA definition for a <code>Result</code> using the optional <code>Error</code> type.\nA section with given type is out of order. All section …\nThe store represents all global state that can be …\nA unique identifier for a specific <code>Store</code>\nThe identifier of a stored object did not match the <code>Store</code> …\nAn access to a table or an element was out of bounds.\nA function specifies too many locals, i.e. more than 2^32 …\nAn extern lookup could not be resolved because no matching …\nMultiple memories are not yet allowed without the proposal.\n…\nThe validation control stack is empty, even though an …\nInformation collected from validating a module.\nA value at runtime. This is essentially a duplicate of …\nThis is a safe variant of <code>Store::access_fuel_mut_unchecked</code>.\nType definitions for addr types\nDefinitions for checked, safe variants of methods defined …\nThis is a safe variant of <code>Store::create_resumable_unchecked</code>…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nEach block contains the validated code section and the stp …\nThis is a safe variant of <code>Store::func_type_unchecked</code>.\nThis is a safe variant of <code>Store::global_alloc_unchecked</code>.\nThis is a safe variant of <code>Store::global_read_unchecked</code>.\nThis is a safe variant of <code>Store::global_type_unchecked</code>.\nThis is a safe variant of <code>Store::global_write_unchecked</code>.\nHelper function to quickly construct host functions …\nA unique identifier for this store. This is used to verify …\nThis is a safe variant of <code>Store::instance_export_unchecked</code>.\nThis module provides types, traits and impls to convert …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is a safe variant of <code>Store::invoke_unchecked</code>.\nThis is a safe variant of …\nThis is a safe variant of …\ncontains <code>Some(remaining_fuel)</code> if instantiation was …\nThis is a safe variant of <code>Store::mem_alloc_unchecked</code>.\nThis is a safe variant of <code>Store::mem_grow_unchecked</code>.\nThis is a safe variant of <code>Store::mem_read_unchecked</code>.\nThis is a safe variant of <code>Store::mem_size_unchecked</code>.\nThis is a safe variant of <code>Store::mem_type_unchecked</code>.\nThis is a safe variant of <code>Store::mem_write_unchecked</code>.\ncontains the store address of the module that has …\nThis is a safe variant of …\nAn address space of modules instantiated within the …\nThis is a safe variant of <code>Store::resume_unchecked</code>.\nNaive implementation of spin based locking mechanisms\nThe start function which is automatically executed during …\nThis is a safe variant of <code>Store::table_alloc_unchecked</code>.\nThis is a safe variant of <code>Store::table_read_unchecked</code>.\nThis is a safe variant of <code>Store::table_size_unchecked</code>.\nThis is a safe variant of <code>Store::table_type_unchecked</code>.\nThis is a safe variant of <code>Store::table_write_unchecked</code>.\nAn address to a data instance that lives in a specific …\nAn address to an element instance that lives in a specific …\nAn address to a function instance that lives in a specific …\nAn address to a global instance that lives in a specific …\nAn address to a memory instance that lives in a specific …\nAn address to a module instance that lives in a specific …\nAn address to a table instance that lives in a specific …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the inner integer represented by this <code>GlobalAddr</code>.\nWe do not wrap <code>ExternAddr</code>s in a <code>Stored</code> object because they …\nA generic stored wrapper. This is used to wrap <code>struct</code> …\nA stored variant of <code>ExternVal</code>\nA stored variant of <code>InstantiationOutcome</code>\nA stored variant of <code>InteropValue</code>\nA StoredInteropValueList is an iterable list of …\nA stored variant of <code>Ref</code>\nA stored variant of <code>RunState</code>\nA stored variant of <code>Value</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTrait that allows user specified configuration for various …\nMaximum number of cascading function invocations\nMaximum number of values in the value stack\nAmount of fuel to be deducted per element of a single byte …\nAmount of fuel to be deducted per element of a  multi-byte …\nAmount of fuel to be deducted when a multi-byte …\nAmount of fuel to be deducted when a multi-byte …\nAmount of fuel to be deducted when a single byte <code>instr</code> is …\nA hook which is called before every wasm instruction\nNaive implementation of spin based locking mechanisms\nThis module contains a data structure to allow in-place …\nAn active element segment’s type and its table’s type …\nAn expr in the code section has trailing instructions …\nThe data count specified in the data count section and the …\nMultiple exports share the same name\nAn <code>else</code> instruction was found while not inside an <code>if</code> block.\nThe end of the binary file was reached unexpectedly.\nAn alignment of some memory instruction is invalid\nA reference type was expected to be on the stack, but a …\nThe lengths of the function and code sections must match.\n33-bit signed integers are sometimes used to encode …\nAn <code>end</code> for a matching <code>if</code> instruction was found, but there …\nAn indirect call to a table with does not store function …\nThe binary format version at the start of the Wasm …\nA custom section contains more bytes than its section …\nAn index for a data segment is invalid.\nAn index for an element segment is invalid.\nAn index for a function is invalid.\nAn index for a global is invalid.\nAn index for a label is invalid.\nAn index for a lane of some vector type is invalid.\nAn index for a local is invalid.\nThe magic number at the start of the Wasm bytecode is …\nAn index for a memory is invalid.\nThe select instructions may work with multiple values in …\nThe function signature of the start function is invalid. …\nAn index for a table is invalid.\nAn index for a type is invalid.\nBlock types use a special 33-bit signed integer for …\nThe discriminator of an element kind is malformed.\nThe discriminator of an export description is malformed.\nThe discriminator of a function type is malformed.\nThe discriminator of an import description is malformed.\nThe discriminator of a limits type is malformed.\nThe min field of a limits type is larger than the max …\nThe discriminator of a mut type is malformed.\nThe discriminator of a number type is malformed.\nThe discriminator of a reference type is malformed.\nThe type of a section is malformed.\nA UTF-8 string is malformed.\nA valtype is malformed because it is neither a number, …\nA variable-length integer was read but it overflowed.\nThe discriminator of a vector type is malformed.\nThe memory size specified by a mem type exceeds the …\nA <code>table.copy</code> instruction referenced two tables that store …\nA <code>table.init</code> instruction specified a table and an element …\nAn expected reference type did not match the actual …\nAn attempt has been made to mutate a const global\nWhen a is referenced in the code section it must be …\nA section with given type is out of order. All section …\nA function specifies too many locals, i.e. more than 2^32 …\nMultiple memories are not yet allowed without the proposal.\nThe validation control stack is empty, even though an …\nConvert this error to a message that is compatible with …\nA struct for managing and reading WASM bytecode\nReturns the argument unchanged.\nEntire WASM binary as slice\nA wrapper function for reads with transaction-like …\nCalls <code>U::from(self)</code>.\nConsumes Self, yielding back the internal reference to the …\nCreate a Span starting from <code>pc</code> for the next <code>len</code> bytes\nCall a closure that may mutate the WasmReader\nAdvance the cursor to the first byte of the provided Span …\nInitialize a new WasmReader from a WASM byte slice\nCurrent program counter, i. e. index of the next byte to …\nRead the current byte without advancing the <code>pc</code>\nReads a new <code>Self</code> from given <code>WasmReader</code>.\nNote: If <code>Err</code>, the WasmReader object is no longer …\nTries to read one byte and fails if the end of file is …\nParses a variable-length <code>u32</code> as specified by LEB128. Note: …\nNote: If <code>Err</code>, the WasmReader object is no longer …\nByte slice to the remainder of the WASM binary, beginning …\nSkip <code>num_bytes</code>, advancing the <code>pc</code> accordingly\nTake <code>N</code> bytes starting from <code>pc</code>, then advance the <code>pc</code> by <code>N</code>\nMethods to read WASM Types from a WasmReader object.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn index and offset to describe a (sub-) slice into WASM …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the length of this Span\nCreate a new Span, starting from <code>from</code> and ranging <code>len</code> …\n…\n…\n…\n…\n…\n…\n…\n…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAll opcodes, in alphanumerical order by their numeric …\nMethods to read basic WASM Values from a WasmReader object.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nParse an elemkind: …\nParse and validate an active segment offset. An active …\nParse and validate the initializer list of an element …\nParse and validate a vector of func_idx’s that reflect …\nHere we can’t implement WasmReadable because we also …\nreturns the external type of <code>self</code> according to typing …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nreturns the external type of <code>self</code> according to typing …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nRelaxed SIMD Proposal\nRelaxed SIMD Proposal\nRelaxed SIMD Proposal\nRelaxed SIMD Proposal\nRelaxed SIMD Proposal\nRelaxed SIMD Proposal\nRelaxed SIMD Proposal\nRelaxed SIMD Proposal\nRelaxed SIMD Proposal\nRelaxed SIMD Proposal\nRelaxed SIMD Proposal\nRelaxed SIMD Proposal\nRelaxed SIMD Proposal\nRelaxed SIMD Proposal\nRelaxed SIMD Proposal\nRelaxed SIMD Proposal\nWasm encodes integers according to the LEB128 format, …\nRead guard for the <code>RwSpinLock</code>\nA spinlock based, read-write lock which favours writers …\nWrite guard for the <code>RwSpinLock</code>\nThe inner data protected by this lock\nLock state (on ambiguity, the state closer to the top …\nEntry to translate the current branches implicit target …\nΔpc: the amount to adjust the instruction pointer by if …\nΔstp: the amount to adjust the side-table index by if the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\npopcnt: the number of values that will be popped if the …\nvalcnt: the number of values that will be copied if the …\nA contigious data structure that never shrinks, but keeps …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHappens when a definition would cause an extern to be …\nThe number of module exports did not match the number of …\nA function was invoked with incorrect parameters or return …\nA host function returned the <code>HaltExecutionError</code>, which …\nA checked method of a <code>Linker</code> was used, even though that …\nAn access to a memory or data was out of bounds.\nFueled execution that is not resumable has ran out of fuel.\nIt was attempted to register a symbol under a name for …\nThe identifier of a stored object did not match the <code>Store</code> …\nAn access to a table or an element was out of bounds.\nAn extern lookup could not be resolved because no matching …\nHelpers for assertions due to prior validation of a WASM …\nDefinitions for checked, safe variants of methods defined …\nHelper function to quickly construct host functions …\nThis module provides types, traits and impls to convert …\nThis module solely contains the actual interpretation loop …\nThis module contains the definition and implementation of …\nA trait for types that might have a <code>StoreId</code> attached to …\nA generic stored wrapper. This is used to wrap <code>struct</code> …\nA stored variant of <code>ExternVal</code>\nA stored variant of <code>InstantiationOutcome</code>\nA stored variant of <code>RunState</code>\nCreates a new stored object\nGets the id of this stored object\nConverts this stored object into its bare form that does …\nChecks if this stored object comes from a specific store …\nHelper method for checking if all <code>Value</code>s in a slice have …\nHelper method for associating every element in a <code>Vec</code> with …\nA stored variant of <code>InteropValue</code>\nA StoredInteropValueList is an iterable list of …\nWe do not wrap <code>ExternAddr</code>s in a <code>Stored</code> object because they …\nA stored variant of <code>Ref</code>\nA stored variant of <code>Value</code>\nTrait that allows user specified configuration for various …\nMaximum number of cascading function invocations\nMaximum number of values in the value stack\nAmount of fuel to be deducted per element of a single byte …\nAmount of fuel to be deducted per element of a  multi-byte …\nAmount of fuel to be deducted when a multi-byte …\nAmount of fuel to be deducted when a multi-byte …\nAmount of fuel to be deducted when a single byte <code>instr</code> is …\nA hook which is called before every wasm instruction\nExecute a previosly-validated constant expression. These …\nHappens when a definition would cause an extern to be …\nThe number of module exports did not match the number of …\nA function was invoked with incorrect parameters or return …\nA host function returned the <code>HaltExecutionError</code>, which …\nA checked method of a <code>Linker</code> was used, even though that …\nAn access to a memory or data was out of bounds.\nFueled execution that is not resumable has ran out of fuel.\nIt was attempted to register a symbol under a name for …\nThe identifier of a stored object did not match the <code>Store</code> …\nAn access to a table or an element was out of bounds.\nAn extern lookup could not be resolved because no matching …\nAn InteropValue is a Rust types that can be converted into …\nAn InteropValueList is an iterable list of InteropValues …\nInterprets wasm native functions. Wasm parameters and Wasm …\nA key used by Wasm modules to identify the names of …\nA linker used to link a module’s imports against extern …\nDefines all exports of some module instance as extern …\nDefines a new extern value in the current <code>Linker</code> context.\nAll extern values in the current linker context by their …\nReturns the argument unchanged.\nTries to get some extern value by its module name and name.\nPerforms initial linking of a <code>ValidationInfo</code>’s imports …\nCalls <code>U::from(self)</code>.\nVariant of <code>Store::module_instantiate_unchecked</code> with …\nCreates a new <code>Linker</code> that is not yet associated to any …\nThis is for the checked API which makes sure that all …\nConvert from and to the little endian byte representation …\nConvert from a byte array to Self\nThis macro implements the <code>LittleEndianBytes</code> trait for a …\nConvert from self to a byte array\nrepresents a resumable that has executed completely with …\nindicates this resumable has never been invoked/resumed to.\nindicates this resumable has been invoked/resumed to at …\nrepresents a resumable that has ran out of fuel during …\nAn object associated to a resumable that is held …\nRepresents the state of a possibly interrupted resumable.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\ncommon convention functions defined for lists of …\n…\nA marker error for host functions to return, in case they …\nRepresents a successful, possibly fueled instantiation of …\nThe store represents all global state that can be …\nA unique identifier for a specific <code>Store</code>\nCalls its argument <code>f</code> with a mutable reference of the fuel …\nType definitions for addr types\n…\n…\nroughly matches …\n…\n…\n…\nCreates a new resumable, which when resumed for the first …\nreturns the external type of <code>self</code> according to typing …\nAllocates a new function with a statically known type …\nAllocates a new function with some host code.\nGets the type of a function by its addr.\nAllocates a new global and returns its global address.\nReturns the current value of some global instance by its …\nReturns the global type of some global instance by its …\nSets a new value of some global instance by its addr.\nA unique identifier for this store. This is used to verify …\nGets an export of a specific module instance by its name\nInvokes a function with a statically known type signature …\nSee: WebAssembly Specification 2.0 - 7.1.7 - func_invoke\nInvokes a function without fuel.\ncontains <code>Some(remaining_fuel)</code> if instantiation was …\nAllocates a new linear memory and returns its memory …\nGrows some memory by its memory address by <code>n</code> pages.\nReads a byte from some memory by its memory address and an …\nGets the size of some memory by its memory address in …\nGets the memory type of some memory by its memory address\nWrites a byte into some memory by its memory address and …\ncontains the store address of the module that has …\nInstantiate a new module instance from a <code>ValidationInfo</code> in …\nAn address space of modules instantiated within the …\nCreates a new empty store with some user data\nCreates a new unique <code>StoreId</code>\nresumes the resumable associated to <code>resumable_ref</code>. Returns …\nAllocates a new table with some table type and an …\nGrows a table referenced by its table address by <code>n</code> …\nReads a single reference from a table by its table address …\nGets the current size of a table by its table address.\nGets the type of some table by its addr.\nWrites a single reference into a table by its table …\nA trait for all address types.\nAn address to a data instance that lives in a specific …\nAn address to an element instance that lives in a specific …\nAn address to a function instance that lives in a specific …\nAn address to a global instance that lives in a specific …\nAn address to a memory instance that lives in a specific …\nAn address to a module instance that lives in a specific …\nAn address to a table instance that lives in a specific …\nReturns the argument unchanged.\nReturns an instance by its address <code>addr</code>.\nReturns a mutable reference to some instance by its …\nMutably borrows two instances by their addresses and …\nInserts a new instance into the current <code>Store</code> and returns …\nCalls <code>U::from(self)</code>.\n…\n…\n…\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n…\n…\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCan never be bigger than 65,356 pages\nindex of the sidetable corresponding to the beginning of …\nMust be of the same type as specified in <code>ty</code>\nImplementation of the linear memory suitable for …\nSize of a page in the linear memory, measured in bytes\nType to express the page count\nCopy <code>count</code> bytes from one region in the linear memory to …\nImplementation of the behavior described in …\nReturns the argument unchanged.\nGrow the <code>LinearMemory</code> by a number of pages\nCalls <code>U::from(self)</code>.\nGet the length in bytes currently allocated to this …\nFrom a given index, load a datum from the <code>LinearMemory</code>\nFrom a given index, load a number of bytes <code>N</code> from the …\nCreate a new, empty <code>LinearMemory</code>\nCreate a new, empty <code>LinearMemory</code>\nGet the number of pages currently allocated to this …\nAt a given index, store a datum in the <code>LinearMemory</code>\nAt a given index, store a number of bytes <code>N</code> in the …\nThe WebAssembly specification defines an externaddr as an …\nA value at runtime. This is essentially a duplicate of …\nAn error used in all <code>TryFrom&lt;Value&gt;</code> implementations for …\nThe WASM spec calls this <code>Activations</code>, however it refers to …\nThe stack at runtime containing\nThe index to the lowermost value on <code>Stack::values</code> that …\nReturns how many call frames are on the stack, in total.\nGet a shared reference to the current <code>CallFrame</code>\nCall frames\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns a shared reference to a specific local by its …\nReturns a mutable reference to a specific local by its …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns a cloned copy of the top value on the stack, or …\nPop a <code>CallFrame</code> from the call stack, returning the caller …\nPop <code>n</code> elements from the value stack’s tail as an …\nPop a value from the value stack\nPush a call frame to the call stack\nPush a value to the value stack\nRemove <code>remove_count</code> values from the stack, keeping the …\nValue that the PC has to be set to when this function …\nStore address of the function that called this <code>CallFrame</code>’…\nNumber of return values to retain on <code>Stack::values</code> when …\nThe index to the lowermost value in <code>Stack::values</code> …\nWASM values on the stack, i.e. the actual data that …\nAn InteropValue is a Rust types that can be converted into …\nAn InteropValueList is an iterable list of InteropValues …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA linker used to link a module’s imports against extern …\nThis is a safe variant of <code>Linker::define_unchecked</code>.\nThis is a safe variant of …\nAll extern values in the current linker context by their …\nReturns the argument unchanged.\nThis is a safe variant of <code>Linker::get_unchecked</code>.\nThis is a safe variant of <code>Linker::instantiate_pre_unchecked</code>…\nCalls <code>U::from(self)</code>.\nThis is a safe variant of …\nThis is for the checked API which makes sure that all …\nrepresents a resumable that has executed completely with …\nindicates this resumable has never been invoked/resumed to.\nindicates this resumable has been invoked/resumed to at …\nrepresents a resumable that has ran out of fuel during …\nAn object associated to a resumable that is held …\nRepresents the state of a possibly interrupted resumable.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRead guard for the <code>RwSpinLock</code>\nA spinlock based, read-write lock which favours writers …\nWrite guard for the <code>RwSpinLock</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nThe inner data protected by this lock\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new instance of self, wrapping the <code>value</code> of type <code>T</code>\nLock state (on ambiguity, the state closer to the top …\ncommon convention functions defined for lists of …\n…\nA marker error for host functions to return, in case they …\nRepresents a successful, possibly fueled instantiation of …\nThe store represents all global state that can be …\nA unique identifier for a specific <code>Store</code>\nType definitions for addr types\nA unique identifier for this store. This is used to verify …\ncontains <code>Some(remaining_fuel)</code> if instantiation was …\ncontains the store address of the module that has …\nAn address space of modules instantiated within the …\nAn address to a data instance that lives in a specific …\nAn address to an element instance that lives in a specific …\nAn address to a function instance that lives in a specific …\nAn address to a global instance that lives in a specific …\nAn address to a memory instance that lives in a specific …\nAn address to a module instance that lives in a specific …\nAn address to a table instance that lives in a specific …\nInformation collected from validating a module.\nReturns the argument unchanged.\nEach block contains the validated code section and the stp …\nCalls <code>U::from(self)</code>.\nThe start function which is automatically executed during …\nValidates a specific branch to some label by its index …\nValidate the data section.\nValidate the global section.\nRead and validate constant expressions.\ncorresponds to <code>opdtype</code> …\nSignal to this struct that the current control block is …\nAttempt popping <code>Valtype::RefType(expected_ty)</code> from type …\nAttempt popping expected_ty from type stack.\nSignal to this struct that a new control block is entered, …\nAssert that the types retrieved from the type stack by …\nCall <code>assert_val_types_on_top</code> for the label signature of …\nAssert that the types retrieved from the type stack by …\nSimilar to <code>ValidationStack::pop_valtype</code>, because it pops a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMark the current control block as unreachable, removing …\nInitialize a new ValidationStack to validate a block of …\nInitialize a new ValidationStack to validate a block of …\nPop a <code>ValidationStackEntry</code> from the <code>ValidationStack</code>\ncorresponds to whether <code>(self, other)</code> is a member of “…\nconvenience method that returns <code>Some(other)</code> if …\nValidate the <code>SELECT</code> instruction within the current control …\nThe WebAssembly specification defines an externaddr as an …\nA value at runtime. This is essentially a duplicate of …\nAn error used in all <code>TryFrom&lt;Value&gt;</code> implementations for …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")